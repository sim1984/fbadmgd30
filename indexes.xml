<!DOCTYPE chapter>
<chapter xmlns="http://docbook.org/ns/docbook" version="5.0" xml:id="indexes" xml:lang="ru">
    <info>
        <title>Индексы</title>
    </info>
    <indexterm>
        <primary>INDEX</primary>
    </indexterm>

    <para>Концепция, положенная в основу индексов, проста и наглядна и является одной из важнейших
        основ проектирования баз данных. На основе индексов базируются многие основополагающие
        объекты базы данных, к тому же правильное использование индексов является ключом к улучшению
        производительности приложений баз данных.</para>

    <para>Индексы — это структуры данных, предназначенные для ускорения доступа к другим данным. В
        СУБД индексы служат для ускорения доступа к данным таблиц. СУБД сама решает какие индексы
        можно использовать для ускорения выполнения конкретного запроса. Индексы поддерживаются СУБД
        автоматически, т.е. администратор БД только однажды создаёт индекс, а далее СУБД сама
        заботится о содержимом индекса</para>

    <para>Что же представляет собой индекс? Индекс — это упорядоченный указатель на записи в
        таблице. <emphasis role="italic">Указатель</emphasis> означает, что индекс содержит значения
        одного или нескольких полей в таблице и адреса страниц данных, на которых располагаются эти
        значения (про страницы данных см. главу "Структура базы данных Firebird"). Другими словами,
        индекс состоит из пар значений "значение поля" — "физическое расположение этого поля". Таким
        образом, по значению поля (или полей), входящего в индекс, при помощи индекса можно быстро
        найти то место в таблице, где располагается запись или записи, содержащая это значение. </para>

    <para><emphasis role="italic">Упорядоченный</emphasis> — означает, что значения полей,
        хранящихся в индексе, упорядочены. </para>
    <para>Очень часто индекс сравнивают с библиотечным каталогом, в котором все книги записаны на
        карточки и упорядочены каким-то образом: по алфавиту или по темам, а в каждой карточке
        написано, где именно в хранилище располагается данная книга. </para>

    <para>Индекс может быть построен на столбцах любого типа кроме <database class="datatype"
            >BLOB</database> и массивов.</para>

    <section>
        <title>Для чего нужны индексы?</title>

        <para>Единственное, чему способствуют индексы, — это ускорению поиска записи по ее
            индексированному полю (индексированное — значит входящее в индекс). </para>

        <para>Итак, основная функция индексов — обеспечивать быстрый поиск записи в таблице. Любое
            использование индексов сводится именно к этому.</para>

        <para>Как реализована эта функция поиска? На входе функции мы имеем значение
            индексированного поля (или нескольких полей). В результате поиска мы должны получить всю
            запись (или несколько записей, если индекс не уникальный), в которой индексированное
            поле имеет заданное значение. Сначала в индексе (точнее, в упорядоченном массиве
            значений индексированного поля) ищется нужное значение, затем берется адрес страницы
            данных, на которой лежит искомая запись, сервер перемещается на эту страницу и читает
            найденную запись. Выглядит довольно громоздко, однако поиск с помощью индекса происходит
            во много раз быстрее, чем при последовательном переборе всех значений из таблицы.</para>

        <para>Если продолжить аналогию индекса с библиотечным каталогом, то поиск записи с помощью
            индекса очень похож на поиск книги с помощью карточки. Стоит нам найти книгу в
            относительно небольшом по объему каталоге (по сравнению со всем библиотечным
            хранилищем), как сразу получаем информацию о точном местонахождении книги и можем
            направиться прямиком туда. Поиск же без использования индекса можно сравнить с
            последовательным перебором всех книг в библиотеке!</para>

        <para>Перебор всех записей в таблице называется прямым или естественным (NATURAL). Надо
            сказать, что, несмотря на мощности современных компьютеров, при достаточно большом
            количестве записей в таблице естественный перебор может быть очень долгим
            процессом.</para>
    </section>
    <section>
        <title>Как устроены индексы</title>

        <para>Индекс не является частью таблицы — это отдельный объект, связанный с таблицей и
            другими объектами базы данных. </para>

        <para>Если говорить о реализации индексов на физическом уровне, то они представляют собой B+
            дерево (сбалансированное дерево поиска). </para>

        <para><emphasis role="italic">Дерево</emphasis> — это структура данных состоящая из
            нескольких узлов, указывающих друг на друга. Выделяют <emphasis role="italic">корень
                дерева</emphasis>, <emphasis role="italic">внутренние</emphasis> и <emphasis
                role="italic">листовые узлы</emphasis>. Все узлы дерева содержат списки пар {ключ,
            указатель). Эти списки отсортированны по значениям ключа. Корень и внутренние узлы
            содержат указатели на дочерние узлы. Листовые узлы содержат указатели на данные,
            соответствующие ключу. Ключ в корне (и во внутреннем узле) равен минимальному ключу из
            соответствующей дочерней страницы. Кол-во узлов от данного узла до листового называют
                <emphasis role="italic">высотой ветки дерева</emphasis>. Максимальная высота всех
            веток, начинающихся в корневом узле называется <emphasis role="italic">высотой
                дерева</emphasis>.</para>
        <para>B-дерево — это такая разновидность дерева в которой высота каждой дочерней ветки
            любого узла всегда одинакова — говорят что такое дерево сбалансированно, отсюда и буква
            B в названии. Сбалансированность дерева обеспечивает одинаковую стоимость доступа
            (кол-во узлов, которые нужно прочитать) к любому ключу, находящемуся в листовом
            узле.</para>
    </section>
    <section>
        <title>Однонаправленность индексов</title>

        <para>Часто узлы б-дерева, находящиеся на одном уровне, образуют двусвязный список, т.е.
            имеют указатели на предыдущий и следующий узел. Это необходимо при сканировании дерева
            при поиске диапазона ключей. Сначала поиском в дереве находят меньший ключ, а затем
            читают узлы дерева последовательно, пока не найдут больший ключ. Индексы в Firebird тоже
            имеют эту особенность. Почему же тогда они однонаправленные, т.е. для поиска
            минимального ключа можно использовать ASC индекс и нельзя использовать DESC индекс, и,
            аналогично, для поиска максимального ключа ASC индекс не подходит, а DESC — подходит?
            Это сделано для обеспечения отсутствия дедлоков при одновременном чтении и модификации
            индекса. Чтение страниц (узлов) индекса всегда осуществляется в одном и том же
            направлении: сверху-вниз и слева-направо. Применение ASC индекса для поиска
            максимального ключа потребует прохода по нижнему уровню справа-налево — это может
            создать конфликтную ситуацию (дедлок), если другой процесс одновременно вставляет ключ в
            индекс. </para>

        <note>
            <para>В июне 2005 года этот вопрос в очередной раз обсуждался в fb-architect и было
                предложено решение как обеспечить сканирование индекса в обратном порядке и
                обеспечить отсутствие дедлоков. Будет ли это реализовано в одной из следующих версий
                Firebird покажет время.</para>
        </note>
    </section>
    <section>
        <title>Применение индексов</title>

        <para>Теперь, когда ясно, что можно требовать от индексов, настало время разобраться с тем,
            какую роль они играют в базе данных. Индексы используются в трех основных случаях:<orderedlist>
                <listitem>
                    <para>Ускорение поиска в таблицах. В этом случае индексы создаются для полей,
                        которые используются в условиях поиска SQL-запросов (предложение WHERE) или
                        условиях соединения таблиц.</para>
                </listitem>
                <listitem>
                    <para>Ускорение сортировок. В этом случае индексы создаются для полей по которым
                        происходит сортировка (предложения ORDER BY), группировка (предложение GROUP
                        BY) или для агрегатных функций MIN и MAX.</para>
                </listitem>
                <listitem>
                    <para>Обеспечение уникальности значений в полях; Ограничение первичного ключа (о
                        которых рассказывалось в главе "Таблицы. Первичные ключи") требует, чтобы во
                        всей таблице не нашлось двух одинаковых значений полей, входящих в первичный
                        ключ. Чтобы выполнить это условие, необходимо при каждой вставке новой
                        записи производить поиск такого же значения, которые будет вставлено. Для
                        поиска записи используется особая разновидность индекса – уникальный индекс
                        (см. ниже).</para>
                </listitem>
                <listitem>
                    <para>Обеспечение ссылочной целостности. Ограничения внешних ключей Foreign key
                        (которые рассмотрены в главе "Ограничения базы данных") используются для
                        проверки того, чтобы вставляемые в таблицу значения обязательно существовали
                        в другой таблице. При создании внешнего ключа автоматически создается
                        индекс, который применяется как для ускорения запросов, использующих
                        соединение таблиц, так и для проверки условий внешнего ключа.</para>
                </listitem>
            </orderedlist></para>

        <para>Вот вкратце и все возможные применения индексов. Теперь мы рассмотрим особенности
            каждого случая более подробно и ответим на ряд часто возникающих вопросов, связанных с
            применением индексов.</para>
    </section>
    <section>
        <title>Ускорение выполнения запросов с помощью индексов</title>

        <para>Выше описано, что применение индексов может значительно ускорить выполнение запросов.
            Это действительно так для большинства случаев, но есть и определенные оговорки. Сначала
            ответим на вопрос, часто возникающий у тех, кто познакомился с индексами. Раз индексы
            ускоряют выборку из базы данных, почему бы не проиндексировать все поля в таблице? Есть
            два момента, препятствующих всеобщей индексации, – это дисковое пространство и издержки
            при модификации данных в таблице. Каждый создаваемый индекс имеет объем, равный объему
            данных в индексированном поле, плюс объем данных о расположении записей. Если создать
            индексы на каждое поле в таблице, то их суммарный объем будет больше, чем объем данных в
            таблице! Поэтому создание большого количества индексов приводит к большому расходу
            дискового пространства.</para>

        <note>
            <para>На самом деле это не совсем так. Во-первых ключи индекса не содержат сами данные.
                Для большинства типов там содержится вещественное число, в которое преобразуется
                значение поля. Для типов CHAR и VARCHAR ключи содержат сами символьные данные.
                Во-вторых к ключам применяется так называемая префиксная компрессия, что позволяет
                резко сократить размер индекса в некоторых случаях. Более точное представление о
                дисковом пространстве занимаем индексом может дать утилита
                    <application>gstat</application>.</para>
        </note>

        <para>Второй момент более важен — это издержки при модификации данных в таблице. В
            реляционной СУБД, как вы знаете, записи в таблицах неупорядочены и потому
            добавление/удаление записей происходят без значительных затрат ресурсов сервера. Даже
            если удаляется запись из середины базы данных, то не происходит перемещения объемов
            данных для того, чтобы закрыть "дыру", — это попросту не нужно: сервер просто пометит
            освободившееся место и при случае запишет туда что-нибудь. Что касается добавления, то
            оно почти всегда происходит в конец таблицы. Однако хотя основные данные в таблице и не
            "дергаются" сервером при модификации, но данные, хранящиеся в индексах,
            переупорядочиваются каждый раз при добавлении/удалении записей! То есть серверу при
            добавлении записи в середину таблицы, например, приходится перестраивать индекс!
            Конечно, реализация индекса некоторым образом рассчитана на частые перестройки, но эти
            действия все же занимают время и ресурсы процессора, а главное ресурсы IO, и при слишком
            большом количестве индексов в таблице модификация данных в ней может быть в десятки раз
            медленнее, чем у такой же таблицы без индексов!</para>

        <para>Это две основные причины, которые препятствуют всеобщей индексации. Помимо них есть и
            еще несколько замечаний, ограничивающих применение индекса. Индексы в Firebird устроены
            довольно эффективно. если запрос на выборку возвращает более 90% записей из таблицы, то
            использование индекса может замедлить выборку данных! Конечно, ситуация зависит от
            конкретного запроса и условий, наложенных на выборку, но нужно помнить, что 90% записей
            являются порогом, когда эффективность использования индексов ставится под вопрос. В
            других СУБД эта величина значительно ниже ~10-20%. Такая эффективность достигается за
            счёт префиксной компрессии ключей и использовании массива битовых масок для указателей
            на страницы данных. Второе замечание формулируется не так очевидно. Оно связано с
            работой оптимизатора Firebird.</para>

        <para>Оптимизатор — это совокупность механизмов, которые разрабатывают план выполнения
            запроса. Когда пользователь передает Firebird какой-либо SQL запрос, он указывает, ЧТО
            должен вернуть сервер в результате выполнения запроса, но не определяет, КАК сервер
            должен выполнять запрос. Оптимизатор на основе переданного запроса строит план его
            выполнения, т. е. откуда и в каком порядке будут читаться потоки данных для соединений
            таблиц и какие индексы будут при этом использоваться. Когда сервер анализирует условия
            на выборку (это в основном части выражения WHERE, ORDER BY, GROUP BY, условия соединений
            и т. д.), то для каждого поля, входящего в условие, сервер пытается использовать индекс.
            К сожалению, алгоритм создания плана несовершенен и оптимизатор может использовать
            индексы, которые не слишком эффективны для конкретного запроса, из-за чего может
            существенно замедлиться время выполнения. Поэтому создание лишних индексов может
            привести к созданию неоптимальных планов. Конечно, разработчики серверов борются с таким
            положением вещей, и последние версии Firebird все лучше и лучше справляются с
            оптимизацией. Работа оптимизатора Firebird подробно описана в статье "Методы
            доступа".</para>

        <para>Третьим случаем, когда индекс не нужен, являются поля с ограниченным набором значений
            — например, поле, которое хранит информацию о поле человека и содержит только два
            возможных значения — "м" и "ж"; нет никакого смысла индексировать это поле. </para>

        <para>Итак, основные ограничения на создание индексов мы рассмотрели. Теперь следует
            рассмотреть вопрос, когда следует использовать индексы, чтобы добиться улучшения
            производительности. Перечислим основные случаи, когда индексация поля(ей) может ускорить
            запрос: <orderedlist spacing="compact">
                <listitem>
                    <para>если это поле используется в условии соединения таблиц (JOIN);</para>
                </listitem>
                <listitem>
                    <para>если это поле используется в условиях поиска запроса (WHERE);</para>
                </listitem>
                <listitem>
                    <para>если это поле используется для группировки (GROUP BY);</para>
                </listitem>
                <listitem>
                    <para>если это поле используется в предложении сортировки ORDER BY;</para>
                </listitem>
                <listitem>
                    <para>если это поле используется в агрегатных функциях MIN и MAX.</para>
                </listitem>
            </orderedlist></para>
        <note>
            <para>Что касается сортировки, надо помнить, что выборка всех записей в порядке ключа
                индекса может быть существенно медленней сортировки без использования индекса.
                Обычно сортировка по индексу позволяет быстро получить первую порцию записей, не
                дожидаясь чтения всех записей, в то время как сортировка без использования индекса
                заставляет прочесть все записи перед тем как вернуть результат. Сортировка с
                использованием индексов хорошо сочетаются, если в запросе используются ограничители
                FIRST, ROWS или FETCH FIRST.</para>
            <para>Функции MIN и MAX далеко не всегда могут использовать индекс, но если это
                возможно, то для MIN необходим восходящий порядок ключей (ASCENDING INDEX), я для
                MAX нисходящий порядок ключей (DESCENDING INDEX).</para>
        </note>

        <para>Если поле применяется указанным выше образом, то создание индекса на него может
            привести к улучшению производительности запроса.</para>
        <indexterm>
            <primary>CREATE INDEX</primary>
        </indexterm>
        <para>Давайте рассмотрим синтаксис создания индексов. Вот полный формат команды DDL, который
            позволяет создавать индексы:
            <programlisting> 
CREATE [UNIQUE] [ASC[ENDING] | DESC[ENDING]] 
INDEX <replaceable>indexname</replaceable> ON <replaceable>tablename</replaceable> 
{(<replaceable>col</replaceable> [, <replaceable>col</replaceable> …]) | COMPUTED BY (<replaceable>&lt;expression&gt;</replaceable>)};                   
                </programlisting>
        </para>
        <para>В следующем примере создадим простейший индекс:
            <programlisting language="sql"> 
CREATE INDEX my_index ON Table_example(ID);                
                </programlisting>
        </para>
        <para>В этом примере создается индекс с именем my_index для таблицы Table_example, причем
            индексированным полем является поле ID. Индекс является возрастающим, т. е. значения в
            нем упорядочены по возрастанию, а также неуникальным, т. е. значит, что поле ID может
            иметь несколько одинаковых значений. Это, конечно же, самый простой пример индекса —
            самый распространенный.</para>
        <para>Как видно из описания синтаксиса, индекс может содержать не одно, а несколько полей.
            Такой индекс используется при часто выполняющихся запросах, которые содержат в условиях
            поиска или сортировки сочетание индексированных полей. Например, если у нас есть
            таблица, содержащая поля Фамилия, Имя, Отчество, то при запросе, использующем сортировку
            по ФИО, будет применен такой индекс. Вообще говоря, необязательно вводить условия на все
            3 поля, применяемые в индексе, чтобы использовать его преимущества. Если мы желаем
            сортировать результат запроса, то индекс будет использован в случае, если первое поле в
            условии сортировки совпадает с первым полем в индексе, например наш индекс будет
            задействован в случае сортировки по Фамилии и Имени.</para>
        <para>В документации для оптимизации выполнения запроса, содержащего в предложении WHERE
            соединение полей с условием OR рекомендуется, использовать не составной индекс, а
            несколько одинарных индексов на все поля, входящие в условие OR.</para>
        <para>К вопросу о порядке сортировки индекса: как видно, он может быть либо возрастающим
            (ASC[ENDING]), либо убывающим (DESC[ENDING]). Зачем нужны разные порядки сортировки?
            Очевидно, для разных сортировок! Если мы желаем сортировать людей по фамилии в
            возрастающем порядке, то создаем возрастающий индекс (ASC), а если в убывающем (от Я до
            А) — то убывающий! А если хотим и то и другое, то необходимо создавать оба
            индекса.</para>
        <indexterm>
            <primary>CREATE INDEX</primary>
            <secondary>COMPUTED BY</secondary>
        </indexterm>
        <para>При создании индекса вместо одного или нескольких столбцов вы также можете указать
            одно выражение, используя предложение COMPUTED BY. Такой индекс называется вычисляемым
            или индексом по выражению. Вычисляемые индексы используются в запросах, в которых
            условие в предложениях WHERE, ORDER BY или GROUP BY в точности совпадает с выражением в
            определении индекса. Выражение в вычисляемом индексе может использовать несколько
            столбцов таблицы. </para>
        <note>
            <para>Не смотря на то, что можно создать вычисляемый индекс по вычисляемому полю,
                использоваться такой индекс не будет.</para>
        </note>
        <para>Давайте посмотрим как можно использовать такой индекс. Вот пример использования
            индекса по выражению для регистронезависимого поиска:
            <programlisting language="sql">
CREATE INDEX IDX_NAME_UPPER ON PERSONS 
COMPUTED BY (UPPER (NAME));                  
                </programlisting>
            Теперь индекс будет использоваться в таком запросе:
            <programlisting language="sql">
SELECT * 
FROM PERSONS 
WHERE UPPER(NAME) STARTING WITH UPPER('Iv');                
                </programlisting>
        </para>
        <indexterm>
            <primary>DROP INDEX</primary>
        </indexterm>
        <para>Для удаления индекса используется оператор DROP INDEX. При наличии зависимостей для
            существующего индекса (если он используется в ограничении) удаление не будет выполнено.
            Синтаксис этого оператора довольно простой:
            <programlisting> 
DROP INDEX <replaceable>indexname</replaceable>;                 
                </programlisting>
        </para>
    </section>
    <section>
        <title>Индексирование символьных типов</title>
        <para>При построении индекса по строковым полям необходимо учитывать ограничение на длину
            ключа индекса. Максимальная используемая длина ключа индекса равна 1/4 размера страницы,
            т.е. от 1024 до 4096 байтов. Максимальная длина индексируемой строки на 9 байтов меньше,
            чем максимальная длина ключа. В таблице приведены данные для максимальной длины
            индексируемой строки (в символах) в зависимости от размера страницы и набора символов,
            её можно вычислить по следующей формуле:
            <programlisting>  
<replaceable>max_char_length</replaceable> = FLOOR((<replaceable>page_size</replaceable> / 4 – 9) / <replaceable>N</replaceable>),                
            </programlisting>
            где <replaceable>N</replaceable> — число байтов на представление символа. </para>
        <para>
            <table frame="all">
                <?dbfo keep-together='auto'?>
                <title>Длина индексируемой строки и набор символов</title>
                <tgroup cols="6">
                    <colspec colname="colPgsz" colnum="1" colwidth="1*" align="center"/>
                    <colspec colname="col1B" colnum="2" colwidth="1*" align="center"/>
                    <colspec colname="col2B" colnum="3" colwidth="1*" align="center"/>
                    <colspec colname="col3B" colnum="4" colwidth="1*" align="center"/>
                    <colspec colname="col4B" colnum="5" colwidth="1*" align="center"/>
                    <colspec colname="col6B" colnum="6" colwidth="1*" align="center"/>
                    <thead>
                        <row>
                            <entry morerows="1">Размер страницы</entry>
                            <entry namest="col1B" nameend="col6B">Максимальная длина индексируемой
                                строки для набора символов, байт/символ</entry>
                        </row>
                        <row>
                            <entry>1</entry>
                            <entry>2</entry>
                            <entry>3</entry>
                            <entry>4</entry>
                            <entry>6</entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry>4096</entry>
                            <entry>1015</entry>
                            <entry>507</entry>
                            <entry>338</entry>
                            <entry>253</entry>
                            <entry>169</entry>
                        </row>
                        <row>
                            <entry>8192</entry>
                            <entry>2039</entry>
                            <entry>1019</entry>
                            <entry>679</entry>
                            <entry>509</entry>
                            <entry>339</entry>
                        </row>
                        <row>
                            <entry>16384</entry>
                            <entry>4087</entry>
                            <entry>2043</entry>
                            <entry>1362</entry>
                            <entry>1021</entry>
                            <entry>682</entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
        </para>
        <note>
            <para>В кодировках, нечувствительных к регистру ("_CI"), один символ в *индексе* будет
                занимать не 4, а 6 (шесть) байт, поэтому максимальная длина ключа для страницы,
                скажем, 4096 байт, составит 169 символов. </para>
        </note>
        <para>Последовательность сортировки (COLLATE) тоже может повлиять на максимальную длину
            индексируемой строки. </para>
    </section>
    <section>
        <title>Обеспечение ссылочной целостности с помощью индексов</title>
        <para>В определении индекса имеется еще одна опция — UNIQUE. Если ее указать, то индекс
            позволит заносить в таблицу только уникальные значения. Фактически это служит основой
            для реализации уникальных ключей (UNIQUIE KEY). Важно помнить, что уникальный индекс не
            является ограничением уникальности.</para>
        <para>Уникальные ключи широко используются в базах данных. Например, первичный ключ — это
            уникальный ключ-индекс, но не всякий уникальный ключ — это первичный ключ. Первичный
            ключ (Primary key) — самый распространенный вид уникального ключа. При создании
            первичного ключа на таблицу автоматически создается уникальный индекс, который получает
            имя, составленное из RDB$PRIMARYNNN, где NNN — последовательный уникальный в пределах
            базы данных номер. Если ограничение целостности имеет имя, то индекс будет с тем же
            именем что и ограничение. При создании ограничения можно задать и другое имя индекса с
            помощью предложения <code>USING [ASC[ENDING] | DESC[ENDING]] INDEX</code>. Таким
            образом, с помощью уникального индекса реализуются два из важнейших ограничений
            ссылочной целостности — уникальный ключ и первичный ключ. </para>
        <para>Уникальные индексы не могут содержать дубликаты значений ключей (или дубликаты
            комбинаций значений ключей в случае составного, многоколоночного или многосегментного
            индекса). Однако, дубликаты значения NULL допускаются в соответствии со стандартом
            SQL-99 (в том числе и в многосегментном индексе). Значения NULL допускают в ограничении
            уникальности (UNIQUE KEY), если не задано ограничение NOT NULL на столбце(ах) на которых
            строится ограничение уникальности. Для первичного ключа (PRIMARY KEY) значение NULL не
            допускается.</para>
        <para>Помимо ограничений уникального и первичного ключа, механизм индексов лежит в основе
            реализации еще одного ограничения ссылочной целостности — внешнего ключа. Ограничение
            внешнего ключа накладывается на одно или несколько полей какой-либо таблицы и
            препятствует внесению в эти поля таких значений, которые не входят в первичный ключ
            другой, родительской таблицы. Для реализации внешнего ключа, т. е. для осуществления
            проверки того, существует ли значение в родительской таблице, автоматически создается
            особый индекс. Он имеет наименование RDB$FOREIGNNN, где NNN — последовательный
            уникальный в пределах базы данных номер. Если внешний ключ имеет имя, то индекс будет с
            тем же именем что и имя внешнего ключа. При создании ограничения можно задать и другое
            имя индекса с помощью предложения <code>USING [ASC[ENDING] | DESC[ENDING]]
            INDEX</code>.</para>
        <important>
            <para>По умолчанию для всех ключей создаётся индекс с ключами в восходящей
                последовательности (ASCENDING). Если вам требуется чтобы ключ использовал индекс с
                нисходящей последовательностью ключей вы можете воспользоваться предложением
                    <code>USING [ASC[ENDING] | DESC[ENDING]] INDEX</code> в определении первичного,
                уникального или внешнего ключа. Следует помнить, что если вы используете DESCENDING
                индекс в первичном или уникальном ключе главной таблицы, то должны использовать
                DESCENDING индекс во внешних ключах подчинённых таблиц, ссылающихся на эту
                таблицу.</para>
        </important>
        <para>Почему именно механизм индексов используется для реализации ограничений ссылочной
            целостности? Дело в том, что индексы в Firebird находятся в особом, привилегированном
            положении — говорят, что они выполняются вне контекста транзакций. Это очень важное
            свойство. О транзакциях мы поговорим позже, в посвященной им главе, а пока лишь скажем,
            что нахождение индексов вне транзакций означает, что все пользователи, одновременно
            работающие с данными в одной и той же таблице, вынуждены соблюдать ограничения ссылочной
            целостности.</para>
    </section>

    <section>
        <title>Обслуживание индексов</title>

        <para>Основным параметром, влияющим на оптимизацию индексного доступа, является
            селективность индекса. <emphasis role="italic">Селективность</emphasis> (<emphasis
                role="italic">избирательность</emphasis>) индекса вычисляется как величина, обратная
            количеству уникальных (разных) ключей в индексе. Уникальный индекс имеет максимальную
            селективность, поскольку при его использовании невозможно выбрать более одной строки для
            каждого значения ключа индекса. Актуальность селективности индекса важна для выбора
            наиболее оптимального плана выполнения запросов оптимизатором. Приведём несколько
            примеров расчёта избирательности индекса:<itemizedlist>
                <listitem>
                    <para>уникальный индекс с N (разными) ключами, избирательность равна 1/N;</para>
                </listitem>
                <listitem>
                    <para>неуникальный индекс с N одинаковыми ключами, избирательность равна
                        1/1;</para>
                </listitem>
                <listitem>
                    <para>неуникальный индекс с ключами {1,1,1,2,2,3,}, избирательность равна
                        1/3.</para>
                </listitem>
            </itemizedlist></para>
        <para><emphasis role="italic">Кардинальность</emphasis> (<emphasis role="italic"
                >cardinality</emphasis>) — величина, характеризующая кол-во ключей индекса,
            удовлетворяющая некоторому значению. Вычисляется как произведение общего количества
            ключей и избирательности. Например, <itemizedlist>
                <listitem>
                    <para>уникальный индекс с N(разными) ключами, кардинальность равна 1;</para>
                </listitem>
                <listitem>
                    <para>неуникальный индекс с N одинаковыми ключами, кардинальность равна
                        N;</para>
                </listitem>
                <listitem>
                    <para>неуникальный индекс с ключами {1,1,1,2,2,3,}, избирательность равна
                        6/3.</para>
                </listitem>
            </itemizedlist></para>
        <para>Очевидно, что чем меньше избирательность, тем меньше кардинальность и, соответственно,
            стоимость выполнения запроса.</para>
        <indexterm>
            <primary>SET STATISTICS INDEX</primary>
        </indexterm>
        <para>Избирательность (статистика) не пересчитывается сервером автоматически. Она
            вычисляется при создании индекса и по специальной команде <code>SET STATISTICS INDEX
                    <replaceable>indexname</replaceable></code>. </para>
        <para>Статистику рекомендуется регулярно пересчитывать вручную (с помощью <code>SET
                STATISTICS INDEX</code>) чтобы оптимизатор строил правильные планы запросов. Обычно
            статистику обновляют после значительных изменений (20% записей) в таблице.</para>

        <para>Пересчёт селективности индекса может быть выполнен под высоко параллельной нагрузкой
            без риска его повреждения. Тем не менее, следует помнить, что при высоком параллелизме
            рассчитанная статистика может устареть, как только закончится выполнение оператора
                <database>SET STATISTICS INDEX</database>. </para>
        <note>
            <para>Узнать селективность индекса, а также некоторые другие связанные с индексом
                характеристики, вы можете узнать с помощью утилиты
                <application>gstat</application>.</para>
            <para>Кроме того селективность индексов можно узнать из системной таблицы RDB$INDICES
                (поле RDB$STATISTICS), для отдельных сегментов индекса статистику можно узнать в
                RDB$INDEX_SEGMENTS (поле RDB$STATISTICS).</para>
        </note>
        <indexterm>
            <primary>ALTER INDEX</primary>
        </indexterm>
        <para>Индекс можно перевести в неактивное состояние. Для этого существует оператор ALTER
            INDEX. Оператор <database>ALTER INDEX</database> переводит индекс в активное/неактивное
            состояние. Возможность изменения структуры и порядка сортировки ключей этот оператор не
            предусматривает. Его синтаксис выглядит следующим образом.
            <programlisting> 
ALTER INDEX <replaceable>indexname</replaceable> {ACTIVE | INACTIVE};                 
                </programlisting>
        </para>

        <indexterm>
            <primary>ALTER INDEX</primary>
            <secondary>INACTIVE</secondary>
        </indexterm>
        <para>При выборе опции <database>INACTIVE</database>, индекс переводится из активного в
            неактивное состояние. Перевод индекса в неактивное состояние по своему действию похоже
            на команду <database>DROP INDEX</database> за исключением того, что определение индекса
            сохраняется в базе данных. Невозможно перевести в неактивное состояние индекс
            участвующий в ограничении.</para>
        <para>Активный индекс может быть отключен, только если отсутствуют запросы использующие этот
            индекс, иначе будет возвращена ошибка <quote>object in use</quote>.</para>
        <para>Активация неактивного индекс также безопасна. Тем не менее, если есть активные
            транзакции, модифицирующие таблицу, то транзакция, содержащая оператор <database>ALTER
                INDEX</database> потерпит неудачу, если она имеет атрибут NO WAIT. Если транзакция
            находится в режиме WAIT, то она будет ждать завершения параллельных транзакций.</para>
        <para>С другой стороны, если наш оператор <database>ALTER INDEX</database> начинает
            перестраивать индекс на <database>COMMIT</database>, то другие транзакции, изменяющие
            эту таблицу, потерпят неудачу или будут ожидать в соответствии с их WAIT/NO WAIT
            атрибутами. Та же самая ситуация будет и при выполнении <database>CREATE
                INDEX</database>.</para>
        <tip>
            <para>Перевод индекса в неактивное состояние может быть полезен при массовой вставке,
                модификации или удалении записей из таблицы, для которой этот индекс построен.
            </para>
        </tip>
        <para>В примере ниже показан перевод индекса IDX_UPDATER в неактивное состояние.
            <programlisting language="sql">
ALTER INDEX IDX_UPDATER INACTIVE;                   
                </programlisting>
        </para>

        <indexterm>
            <primary>ALTER INDEX</primary>
            <secondary>ACTIVE</secondary>
        </indexterm>
        <para>При выборе альтернативы <database>ACTIVE</database> индекс переводится из неактивного
            состояния в активное. При переводе индекса из неактивного состояния в активное индекс
            перестраивается.</para>
        <tip>
            <para>Даже если индекс находится в активном состоянии оператор <database>ALTER INDEX ...
                    ACTIVE</database> всё равно перестраивает индекс. Таким образом, эту команду
                можно использовать как часть обслуживания БД, для индексов большой таблицы в которую
                происходят частые вставки, обновления и удаления. для перестройки индексов,
                автоматически созданных для ограничений <database>PRIMARY KEY</database>,
                    <database>FOREIGN KEY</database>, <database>UNIQUE</database>, для которых
                выполнение оператора <database>ALTER INDEX ... INACTIVE</database> невозможно.
            </para>
        </tip>
        <note>
            <para>Часто можно услышать мнение, что индексы необходимо перестраивать из-за того что
                они со временем разбалансируются. На самом деле разбалансировка индексов — это миф.
                Б-берево не может быть разбалансировано в принципе. Однако перестройка индексов
                позволяет избежать физической фрагментации страниц дерева (т.е. увеличивает шанс
                последовательного расположения страниц на диске) и более равномерно распределить
                значения в узлах (т.е. заполнить страницы данными более-менее плотно и
                одинаково).</para>
        </note>

        <para>Если мы решили вернуть индекс IDX_UPDATER в активное состояние следует выполнить
            оператор:
            <programlisting language="sql">
ALTER INDEX IDX_UPDATER ACTIVE;                 
                </programlisting>
        </para>

        <para>Принудительный перевод индексов созданных для ограничений <database>PRIMARY
                KEY</database>, <database>FOREIGN KEY</database> и <database>UNIQUE</database> не
            допускается. Тем не менее, выполнение оператора <database>ALTER INDEX ...
                INACTIVE</database> работает так же хорошо для индексов ограничений как и другие
            инструменты для других индексов. Это позволяет "починить" индекс если по какой-то
            причине он оказался битым.</para>
    </section>
</chapter>
