<?xml version="1.0" encoding="UTF-8"?>
<?xml-model href="http://docbook.org/xml/5.1/rng/docbook.rng" schematypens="http://relaxng.org/ns/structure/1.0"?>
<?xml-model href="http://docbook.org/xml/5.1/sch/docbook.sch" type="application/xml" schematypens="http://purl.oclc.org/dsdl/schematron"?>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"
    version="5.1" xml:lang="ru" xml:id="mon-tools">
    <info>
        <title>Использование инструментов мониторинга Firebird</title>
    </info>

    <para/>

    <section>
        <title>Использование fb_lock_print</title>
        <para>Утилита <application>fb_lock_print</application> служит для получения информации о
            состоянии лок-менеджера ФБ. Информация может быть выведена как в виде заголовка
            лок-таблицы, так и в виде развернутых данных о видах ресурсов, на которые установлены
            блокировки, владельцах этих блокировок и тех соединениях, кто ждёт высвобождения
            ресурсов (если такие есть).</para>
        <para>Операция получения заголовка лок-таблицы выполняется очень быстро, без затрат
            ресурсов. Получение развернутой информации может потребовать (при сильной нагрузке)
            десятков секунд, в течение которых работа с базой будет приостановлена. Лог вывода при
            этом может достигать десятков и даже сотен мегабайт.</para>
        <para>Утилита должна запускаться на том же сервере, где работает база (т.е. возможности
            удаленно получить содержимое лок-таблицы на сегодня нет).</para>
        <para>Вызов может проводиться как для получения информации по конкретной базе данных (ключ
            "-d"), так и для получения информации о лок-таблице по имени её файла (ключ
            "-f").</para>
        <para>При использовании ключа "-d", допускается указывать как файл, так и алиас базы.</para>
        <para>Если над базой активно проводятся операции записи, то для получения консистентного
            состояния лок-таблицы настоятельно рекомендуется указывать дополнительно ключ "-c". Этот
            ключ приведёт к блокировке лок-таблицы, затем будет создана её копию, после чего
            лок-таблица разблокируется и анализ будет уже идти по данным из созданной копии.</para>
        <para>В противном случае возможно зацикливание <application>fb_lock_print</application> и
            получение бесконечного растущего лога. Кроме того, возможен вывод значений, совершенно
            невозможных с точки зрения здравого смысла, например:</para>
        <screen>
Free requests (-1297897313): forward: 1052750528, backward: 997957440            
        </screen>

        <para>Лок-таблица для базы создается в момент установки первого соединения с этой базой.
            Вызов <application>fb_lock_print</application> с указанием базы, к которой нет
            подключений, приведёт к выводу:</para>
        <itemizedlist>
            <listitem>
                <para>в поток STDOUT — сообщения "Unable to access lock table";</para>
            </listitem>
            <listitem>
                <para>в поток STDERR — сообщения, текст которого зависит от операционной системы: <itemizedlist>
                        <listitem>
                            <para>Linux: "shmem_data->sh_mem_length_mapped is 0"</para>
                        </listitem>
                        <listitem>
                            <para>Windows: "File for memory mapping is empty".</para>
                        </listitem>
                    </itemizedlist></para>
            </listitem>
        </itemizedlist>

        <para>Код возврата (bash: $?; batch: errorlevel) при указании команде
                <application>fb_lock_print</application> несуществующего файла БД или при указании
            базы, к которой нет подключений, всегда одинаковый и равен нулю.</para>

        <section>
            <title>Структура заголовка лок-таблицы</title>

            <para>При указании только имени базы (возможно, с ключом "-c"), выводится ЗАГОЛОВОК
                лок-таблицы.</para>

            <para>Примеры вызова, возвращающие только заголовок лок-таблицы:</para>
            <synopsis>
/opt/firebird/bin/fb_lock_print -c 
    -d employee 1>/tmp/lkp_employee.log 2>/tmp/lkp_employee.err
    
/opt/firebird/bin/fb_lock_print -f 
    /tmp/firebird/fb_lock_00fd0000000000009400220000000000 1>/tmp/lkp.log 2>
    /tmp/lkp.err                
            </synopsis>

            <note>
                <para>Некоторые строки в командах перенесены на другую строку.</para>
            </note>
            <para>Пример заголовка (с нумерацией строк):</para>
            <synopsis>
/opt/firebird/bin/fb_lock_print -c -d employee | cat -n                
            </synopsis>
            <screen linenumbering="numbered"><![CDATA[LOCK_HEADER BLOCK
         Version: 146, Creation timestamp: 2017-12-07 11:42:46
         Active owner:      0, Length: 5242880, Used: 235688
         Enqs:   1195, Converts:     26, Rejects:     30, Blocks:     15
         Deadlock scans:      3, Deadlocks:      2, Scan interval:  33
         Acquires:   2150, Acquire blocks:     14, Spin count:   0
         Mutex wait: 0.7%
         Hash slots: 20011, Hash lengths (min/avg/max):    0/   0/   4
         Remove node:      0, Insert queue:      0, Insert prior:      0
         Owners (3):     forward: 172960, backward: 208096
         Free owners (2):        forward: 226648, backward: 217480
         Free locks (17):        forward: 174344, backward: 233744
         Free requests (236):    forward: 235544, backward: 224360]]></screen>


            <orderedlist>
                <listitem>
                    <para>LOCK_HEADER BLOCK</para>
                </listitem>
                <listitem>
                    <para><code>Version: 146, Creation timestamp: 2017-12-07 11:42:46</code></para>
                    <para>Номер версии лок-таблицы и штамп времени, когда к базе был установлен
                        первое подключение.</para>
                </listitem>
                <listitem>
                    <para><code>Active owner: 0, Length: 5242880, Used: 235688</code></para>

                    <itemizedlist>
                        <listitem>
                            <para>Active owner — номер соединения с сервером, который в данный
                                момент занимает лок-таблицу. При запуске fb_lock_print с ключом "-c"
                                это значение всегда равно нулю.</para>
                        </listitem>
                        <listitem>
                            <para>Length — общий объём памяти, выделенный под лок-таблицу, см
                                параметр LockMemSize в firebird.conf (databases.conf). </para>
                            <para>Существует эмпирическое правило для выбора этого значения: <equation>
                                    <mathphrase>LockMemSize_bytes = db_cache_pages *
                                        count_of_connections * 100</mathphrase>
                                </equation>, где </para>
                            <itemizedlist spacing="compact">
                                <listitem>
                                    <para>db_cache_pages — размер страничного кеша Firebird;</para>
                                </listitem>
                                <listitem>
                                    <para>count_of_connections — ожидаемое максимальное количество
                                        подключений.</para>
                                </listitem>
                            </itemizedlist>
                            <para>Однако, правильнее выполнять мониторинг параметра Used лок-таблицы
                                в течении дня и устанавливать LockMemSize в значение, большее чем
                                зафиксированный максимум used в полтора-два раза.</para>
                        </listitem>
                        <listitem>
                            <para>Used — Объём памяти, используемый в момент получения снимка. Не
                                уменьшается, пока существует хотя бы 1 коннект. Когда Used будет
                                больше значения (Length - LockMemSize), произойдёт увеличение
                                размера лок-таблицы на число, указанное в параметре LockMemSize
                                файла конфигурации <filename>firebird.conf</filename>
                                    (<filename>databases.conf</filename>).</para>
                        </listitem>
                    </itemizedlist>

                </listitem>
                <listitem>
                    <para><code>Enqs: 1195, Converts: 26, Rejects: 30, Blocks: 15</code></para>
                    <itemizedlist>
                        <para>Строка со счетчиками операций:</para>
                        <listitem>
                            <para>Enqs — запросы на установку новой блокировки;</para>
                        </listitem>
                        <listitem>
                            <para>Converts — изменения статуса блокировки (например, понижение её с
                                монопольной до shared)</para>
                        </listitem>
                        <listitem>
                            <para>Rejects — отказы в получении блокировки</para>
                        </listitem>
                        <listitem>
                            <para>Blocks — число ожиданий высвобождения ресурсов, на которые другими
                                соединениями были ранее установлены блокировки с уровнями,
                                несовместимыми с теми, которые запрашивают ожидающие соединения;
                                например, подключение, запрашивающий страницу на чтение, будет
                                ожидать её высвобождения, если на неё установлена блокировка для
                                записи другим соединением.</para>
                        </listitem>
                    </itemizedlist>
                </listitem>
                <listitem>
                    <para><code>Deadlock scans: 3, Deadlocks: 2, Scan interval: 33</code></para>
                    <itemizedlist>
                        <listitem>
                            <para>Deadlock scans — число длительных ожиданий (возможно,
                                продолжающихся и сейчас) установки блокировок на ресурсы. Под
                                "длительными" понимаются ожидания, превосходящие значение
                                    <parameter>DeadLockTimeout</parameter> секунд, указанное в
                                конфигурации
                                    <filename>firebird.conf</filename>/<filename>databases.conf</filename>.</para>
                            <para>Это общее число неудачных попыток установить блокировку на
                                какой-либо ресурс в рамках либо WAIT-транзакций, либо транзакций,
                                запущенных с <code>LOCK TIMEOUT
                                    &lt;<replaceable>n</replaceable>&gt;</code>, где число
                                    <replaceable>n</replaceable> больше, чем параметр конфигурации
                                    <parameter>DeadLockTimeout</parameter>. Равно сумме таких
                                попыток по всем соединениям (т.е. 10 соединений могли ждать только 1
                                раз, но также могли ждать и 5 соединений 2 раза; какой именно был
                                сценарий — определить невозможно).</para>
                            <para>Накапливается с момента первого подключения к базе, меняется
                                только в рамках WAIT-транзакций.</para>
                            <para>Высокое значение может говорить о частых попытках вставок записей
                                с одинаковыми ключами в уникальный индекс или о конфликтах, при
                                которых транзакции_1 нужен ресурс транзакции_2, и наоборот (эта
                                ситуация называется "deadlock").</para>
                            <para>Также, это значение может оказаться высоким при групповом удалении
                                подключений с использованием <database class="table"
                                    >mon$attachments</database>.</para>
                        </listitem>
                        <listitem>
                            <para>Deadlocks — накопленное количество длительных ожиданий из
                                множества, определенного в Deadlock scans, завершившихся
                                ошибками.</para>
                        </listitem>
                        <listitem>
                            <para>Scan interval — Значение параметра ожидания
                                    <parameter>DeadLockTimeout</parameter>, заданного в
                                    <filename>firebird.conf</filename>/<filename>databases.conf</filename>.</para>
                        </listitem>
                    </itemizedlist>

                </listitem>
                <listitem>
                    <para><code>Acquires: 2150, Acquire blocks: 14, Spin count: 0</code></para>

                    <itemizedlist>
                        <listitem>
                            <para>Acquires — общее количество обращений к лок-таблице с момента
                                старта ФБ.</para>
                            <para>В случае, когда соединение висит в ожидании ресурса (например, в
                                WAIT-транзакции), этот счетчик увеличивается на 1 каждые
                                    <parameter>DeadLockTimeout</parameter> секунд.</para>
                            <para>Может служить индикатором того, насколько интенсивно операция
                                обращается к лок-менеджеру. Например, каждое новое соединение,
                                устанавливаемое к базе утилитой ISQL, требует 86 обращений (первое —
                                более 120). Каждое новое соединение, выполняемое с помощью
                                Python-драйвера, требует 78 обращений. Таким образом, даже операция
                                установки соединения с базой данных требует доступа к лок-таблице и,
                                следовательно, влияет на количество соединений, которые ждут доступа
                                к ней (см следующую секцию, "mutex wait, %").</para>
                        </listitem>
                        <listitem>
                            <para>Acquire blocks — число обращений, которые привели к ожиданию на
                                мьютексе (лок-таблица была занята).</para>
                        </listitem>
                        <listitem>
                            <para>Spin count — значение <parameter>LockAcquireSpins</parameter> из
                                файла конфигурации
                                    (<filename>firebird.conf</filename>/<filename>databases.conf</filename>).</para>
                        </listitem>
                    </itemizedlist>

                </listitem>
                <listitem>
                    <para><code>Mutex wait, %</code></para>
                    <para>Перед обновлением лок-таблицы процесс устанавливает на неё блокировку,
                        называемую мьютексом. mutex wait,% — это процент от общего числа процессов,
                        что вынуждены были ждать доступа к лок-таблице ввиду её обновления каким-то
                        одним из соединений. Значение получается в момент получения снимка
                        лок-таблицы и может меняться в любую сторону. Вычисляется по формуле: <equation>
                            <mathphrase>mutex wait = acquire blocks / acquires * 100%</mathphrase>
                        </equation></para>
                    <para>В обычных производственных базах под нагрузкой может достигать
                        25-35%.</para>
                    <para>Большее значение может быть объяснено либо слишком длинными цепочками (см.
                        ниже, Hash Lenghts; в этом случае надо увеличивать значение параметра
                            <parameter>LockHashSlots</parameter>), либо чрезмерно высокой нагрузкой
                        на сервер от приложения.</para>
                    <note>
                        <para>В архитектуре SuperServer нет страничных блокировок, лок-таблица
                            используется редко, поэтому значение параметра mutex wait очень часто
                            близко к нулю.</para>
                    </note>
                </listitem>
                <listitem>
                    <para><code>Hash slots: 20011, Hash lengths (min/avg/max): 0/ 0/ 4</code></para>

                    <itemizedlist>
                        <listitem>
                            <para>Hash slots — это количество "кустов" в хеш-таблице, по которым
                                распределяются данные о ресурсах и установленных блокировках. Чем
                                больше это число, тем меньше длина цепочек, которые возникают при
                                коллизиях хеш-значений. Максимально допустимое значение этого
                                параметра равно 65521 (значения больше этого порога игнорируются и
                                используется всё равно именно этот порог: 65521).</para>
                            <para>Значение по умолчанию (8191) можно считать подходящим для работы
                                100 пользователей и умалчиваемом размере страничного кеша
                                (256).</para>
                            <para>Значение берётся из конфигурационного файла
                                    (<filename>firebird.conf</filename>/<filename>databases.conf</filename>),
                                параметр <parameter>LockHashSlots</parameter>. Рекомендуется
                                назначать этот параметр равным простому числу. </para>
                        </listitem>
                        <listitem>
                            <para>Hash lengths (min/avg/max) — минимальное, среднее арифметическое и
                                максимальное значение длины цепочек в лок-таблице, вычисленные в
                                момент получения снимка.</para>
                            <para>Вычисляются каждый раз как результат просмотра содержимого всех
                                слотов, потому меняются при каждом запросе вывода лок-таблицы, в том
                                числе в сторону уменьшения (т.е. никакого накопления "с начала
                                работы" по ним нет).</para>
                            <para>Среднее арифметическое учитывает все слоты таблицы, в том числе —
                                с нулевыми значениями длин цепочек (т.е. пустые).</para>
                            <para>Если в нескольких снимках подряд любое из значений достигает
                                лимитов:
                                <literallayout class="monospaced">
min >= 5, avg >= 8...10, max >= 13...15                                        
                                    </literallayout>
                                то следует увеличить параметры <parameter>LockHashSlots</parameter>
                                и <parameter>LockMemSize</parameter>. </para>
                            <para>Эффект от новых значений будет достигнут только при отсоединении
                                всех соединений от всех баз, которые работают на сервере.</para>
                        </listitem>
                    </itemizedlist>

                </listitem>
                <listitem>
                    <para/>
                </listitem>
                <listitem>
                    <para><code>Owners (3) ...</code> — количество соединений, которые существуют в
                        момент получения снимка.</para>
                </listitem>
                <listitem>
                    <para><code>Free owners (2) ...</code> — разность между максимальным количеством
                        соединений, которые были в базе данных с момента старта Firebird, и текущим
                        их числом. Другими словами, Free Owners — это число соединений, которые
                        прекратили свою работу и отсоединились от базы.</para>
                </listitem>
            </orderedlist>

        </section>
        <section>
            <title>Детализация лок-таблицы</title>

            <section>
                <title>Представление ресурсов как блокировок различных видов</title>
                <para>Ресурсы, которые на момент получения снимка лок-таблицы находились в
                    использовании (или запрашивались для использования), представлены в виде блоков
                    записей, начинающихся с фразы <code>LOCK BLOCK
                            <replaceable>&lt;nnnnnn&gt;</replaceable></code>. Эти блоки записей дают
                    информацию о виде блокировок и их состоянии. Таким образом, ресурсы (то, за что
                    часто идёт борьба) представлены в лок-таблице опосредовано, через
                    блокировки.</para>
                <para>В СУБД Firebird определены следующие виды блокировок (см.
                        <filename>src/jrd/lck.h</filename>): </para>
                <orderedlist>
                    <listitem>
                        <para><code>LCK_database</code> — Root of lock tree</para>
                        <para>Монопольная блокировка базы. В архитектуре Classic Server
                            предоставляется первому процессу, выполнившему соединение. Второе
                            подключение, пытающееся установить соединение, "видит" монопольную
                            блокировку, уже выданную первому, и посылает ему сигнал о необходимости
                            понизить уровень блокировки с exclusive до shared. В итоге, обе
                            блокировки на базу приходят к уровню "разделяемое чтение". В архитектуре
                            Superserver база устанавливает монопольную блокировку сама на
                            себя.</para>
                    </listitem>
                    <listitem>
                        <para><code>LCK_relation</code> — Individual relation lock</para>
                        <para>Блокировка на таблицу (как объект БД) при чтении или записи данных в
                            неё.</para>
                        <para>При любых операциях таблицы блокируются в разделяемом режиме и это не
                            влияет на параллельный доступ. Исключения, накладывающие более высокие
                            уровни блокировки: <itemizedlist spacing="compact">
                                <listitem>
                                    <para>создание индекса</para>
                                </listitem>
                                <listitem>
                                    <para>онлайн-валидация</para>
                                </listitem>
                                <listitem>
                                    <para>операции в транзакции уровня изоляции consistency (aka
                                        SNAPSHOT TABLE STABILITY), либо при явном задании блокировок
                                        таблиц в транзакции (фраза RESERVING в SET
                                        TRANSACTION)</para>
                                </listitem>
                            </itemizedlist></para>
                        <para>Также эксклюзивная блокировка <code>LCK_relation</code> со специальным
                            ключом -1 берется при генерации нового ID для создаваемой
                            таблицы.</para>
                    </listitem>
                    <listitem>
                        <para><code>LCK_bdb</code> — Individual buffer block</para>
                        <para>Блокировка любой физической страницы, независимо от её типа (таблица
                            или индекс или что-то другое).</para>
                    </listitem>
                    <listitem>
                        <para><code>LCK_tra</code> — Individual transaction lock</para>
                        <para>Эксклюзивная блокировка транзакции тем, кто ее стартовал. Остальные
                            могут пытаться брать разделяемую блокировку для определения состояния
                            (активности) транзакции, либо ждать на такой блокировке до окончания
                            текущей транзакции (в режиме WAIT).</para>
                    </listitem>
                    <listitem>
                        <para><code>LCK_rel_exist</code> — Relation existence lock</para>
                        <para>Блокировка-защита существования таблицы; в Key записан ID таблицы
                            (rdb$relations.rdb$relation_id).</para>
                    </listitem>
                    <listitem>
                        <para><code>LCK_idx_exist</code> — Index existence lock</para>
                        <para>Блокировка-защита существования индекса; в "Key" записаны: старшие два
                            байта — ID таблицы, младшие — ID индекса.</para>
                    </listitem>
                    <listitem>
                        <para><code>LCK_attachment</code> — Attachment lock</para>
                        <para>Монопольная блокировка, устанавливаемая процессом, соединившимся с
                            базой, на объект его собственного соединения. Через эту блокировку
                            происходит уведомление соединения о его принудительном
                            завершении.</para>
                    </listitem>
                    <listitem>
                        <para><code>LCK_shadow</code> — Lock to synchronize addition of
                            shadows</para>
                        <para>Блокировка для синхронизации добавления теневых копий к базе.</para>
                    </listitem>
                    <listitem>
                        <para><code>LCK_sweep</code> — Sweep lock for single sweeper</para>
                        <para>Блокировка для гарантии существования только одного
                            sweep-процесса.</para>
                    </listitem>
                    <listitem>
                        <para><code>LCK_expression</code> — Expression index caching
                            mechanism</para>
                        <para>Блокировка-защита неизменности выражения для вычисляемого
                            индекса.</para>
                    </listitem>
                    <listitem>
                        <para><code>LCK_prc_exist</code> — Procedure existence lock</para>
                        <para>Блокировка-защита существования хранимой процедуры. Применяется только
                            процедур. Для функций используется <code>LCK_fun_exist</code>. Для
                            триггеров такой защиты нет.</para>
                    </listitem>
                    <listitem>
                        <para><code>LCK_update_shadow</code> — shadow update sync lock</para>
                        <para>Блокировка для сериализации обновлений теневой копии (обновляться
                            должна только одним процессом).</para>
                    </listitem>
                    <listitem>
                        <para><code>LCK_backup_alloc</code> — Lock for page allocation table in
                            backup spare file</para>
                        <para>nbackup: блокировка, синхронизирующая доступ к таблице соответствия
                            страниц внутри дельта-файла.</para>
                    </listitem>
                    <listitem>
                        <para><code>LCK_backup_database</code> — Lock to protect writing to database
                            file</para>
                        <para>nbackup: блокировка физического состояния базы данных
                            (normal/stalled/merge). Управляет направлением чтения/записи между
                            файлом БД и дельта-файлом.</para>
                    </listitem>
                    <listitem>
                        <para><code>LCK_backup_end</code> — Lock to protect end_backup
                            consistency</para>
                        <para>nbackup: блокировка для обеспечения слияния дельты в основной файл в
                            единственном процессе.</para>
                    </listitem>
                    <listitem>
                        <para><code>LCK_rel_partners</code> — Relation partners lock</para>
                        <para>Блокировка-защита существования ограничения ссылочной целостности
                            (ссылки по внешнему ключу) между таблицами.</para>
                    </listitem>
                    <listitem>
                        <para><code>LCK_page_space</code> — Page space ID lock</para>
                        <para>Блокировка для уникальной идентификации пространства страниц для
                            GTT.</para>
                    </listitem>
                    <listitem>
                        <para><code>LCK_dsql_cache</code> — DSQL cache lock</para>
                        <para>Блокировка актуальности состояния объектов кеша метаданных.</para>
                        <para>В движке существует два кеша метаданных: на уровне парсера и на уровне
                            ядра. Блокировки <code>LCK_dsql_cache</code> используются, чтобы
                            инвалидировать объекты в кеше первого уровня.</para>
                    </listitem>
                    <listitem>
                        <para><code>LCK_monitor</code> — Lock to dump the monitoring data</para>
                        <para>Блокировка актуальности состояния данных мониторинга для
                            соединения.</para>
                    </listitem>
                    <listitem>
                        <para><code>LCK_tt_exist</code> — TextType existence lock</para>
                        <para>Блокировка-защита существования collate (правила сопоставления
                            символов для упорядоченного вывода текста).</para>
                    </listitem>
                    <listitem>
                        <para><code>LCK_cancel</code> — Cancellation lock</para>
                        <para>Блокировка для уведомления об отмене текущей операции.</para>
                    </listitem>
                    <listitem>
                        <para><code>LCK_btr_dont_gc</code> — Prevent removal of btree page from
                            index</para>
                        <para>Блокировка-защита от удаления страницы в индексе, расположенной слева
                            от вставляемой новой страницы.</para>
                    </listitem>
                    <listitem>
                        <para><code>LCK_shared_counter</code> — Databasewide shared counter</para>
                        <para>Блокировка, синхронизирующая генерацию уникальных идентификаторов для
                            запросов (а также для соединений и транзакций в read-only БД).</para>
                    </listitem>
                    <listitem>
                        <para><code>LCK_tra_pc</code> — Precommitted transaction lock</para>
                        <para>Блокировка-признак precommitted транзакции (для них не создается
                                <code>LCK_tra</code> блокировка), используется для проверки
                            состояния транзакции.</para>
                    </listitem>
                    <listitem>
                        <para><code>LCK_rel_gc</code> — Allow garbage collection for relation</para>
                        <para>Блокировка, разрешающая/запрещающая сборку мусора в определенной
                            таблице (и ее индексах).</para>
                    </listitem>
                    <listitem>
                        <para><code>LCK_fun_exist</code> — Function existence lock</para>
                        <para>Блокировка-защита существования UDF и PSQL-функции.</para>
                    </listitem>
                    <listitem>
                        <para><code>LCK_rel_rescan</code> — Relation forced rescan lock</para>
                        <para>Блокировка состояния метаданных таблицы, используется для обновления
                            информации в кеше метаданных (после ALTER TABLE).</para>
                    </listitem>
                    <listitem>
                        <para><code>LCK_crypt</code> — Crypt lock for single crypt thread</para>
                        <para>Блокировка для обеспечения работы потока шифрования в единственном
                            экземпляре.</para>
                    </listitem>
                    <listitem>
                        <para><code>LCK_crypt_status</code> — Notifies about changed database
                            encryption status</para>
                        <para>Блокировка текущего состояния шифрования БД (зашифрована или
                            нет).</para>
                    </listitem>
                    <listitem>
                        <para><code>LCK_record_gc</code> — Recordlevel GC lock</para>
                        <para>Блокировка, разрешающая/запрещающая сборку мусора для конкретной
                            записи.</para>
                    </listitem>
                </orderedlist>
                <para>Числовые индексы 1...30, приведенные в этом списке, используются в отображении
                    типа блокировки как <quote>номер серии</quote> (см ниже, подстрока
                        <quote>Series:</quote>). Эти индексы следует использовать для определения
                    того, какой вид блокировки выведен.</para>
            </section>
            <section>
                <title>Особенности при работе в архитектуре SuperServer. Латчи (latches)</title>
                <para>В архитектуре SuperServer отсутствует блокировка LCK_bdb (<quote>Individual
                        buffer block</quote>), поэтому использование лок-таблицы для поиска очередей
                    на доступ к страницам базы результата не даст. Вместо блокировок страниц в
                    SuperServer используются так называемые <quote>страничные латчи</quote> —
                    легковесные механизмы сериализации.</para>
                <para>Латчи (latches) более эффективные, но при этом работают в рамках текущего
                    процесса, имеют только два состояния (exclusive/shared), не умеют посылать
                    сигналы другим процессам, не умеют находить и обрабатывать состояния взаимных
                    блокировок (deadlock-состояния). Обычные блокировки (в отличие от латчей)
                    работают через лок-менеджер. Они <quote>сложные</quote> по реализации, находятся
                    в разделяемой памяти, умеют сигнализировать другим процессам, имеют 6 возможных
                    состояний, умеют диагностировать состояния взаимных блокировки. </para>

                <para>Доступ ко всем общим ресурсам, которые требуют рассылки сигналов,
                    сериализуется в архитектуре SuperServer так же как в Classic/Superclassic —
                    через обычные блокировки (например, это блокировки метаданных).</para>
            </section>
            <section>
                <title>Данные о владельцах блокировок (OWNER BLOCK)</title>

                <para>Вывод информации о владельцах блокировок осуществляется указанием ключа
                        <code>-o</code>.</para>
                <para>Информация о владельцах блокировок собрана в блоки, начинающиеся с фразы
                        <code>OWNER BLOCK &lt;<replaceable>nnnnnn</replaceable>&gt;</code>.</para>
                <para>Ниже приведен пример вызова <application>fb_lock_print</application>, при
                    котором выводится информация о владельце единственной блокировки, существующей в
                    базе. Это происходит при установке к БД единственного подключения: </para>
                <synopsis>
# /opt/firebird/bin/fb_lock_print -c -d employee -o | cat -n                    
                </synopsis>
                <screen>
 1  LOCK_HEADER BLOCK
            ...
10          Owners (1):     forward: 172960, backward: 172960
            ...
14
15  OWNER BLOCK 172960
16          Owner id: 13494787244039, Type: 1
17          Process id:   3142 (Alive), Thread id:   3144
18          Flags: 0x00
19          Requests (80):  forward: 173144, backward: 186040
20          Blocks: *empty*
21          Pending: *empty*
22
                        
                    </screen>

                <para>В строке 16 <code>Owner id: 13494787244039, Type: 1</code> — содержится
                    указание на тип владельца блокировки.</para>
                <itemizedlist>
                    <listitem>
                        <para>Type = 1 — это сама база данных (LCK_database), она устанавливает
                            монопольную блокировку на саму себя при установке первого соединения.
                            Второе соединение выдаст сигнал первому о необходимости понижения уровня
                            блокировки, и она будет понижена до shared read.</para>
                    </listitem>
                    <listitem>
                        <para>Type = 2 — указывается, когда собственником блокировки является
                            некоторое соединение с базой данных.</para>
                    </listitem>
                </itemizedlist>
                <para>В строке 17 <code>Process id: 3142 (Alive), Thread id: 3144</code> — указан ID
                    отдельного процесса Firebird, созданного при подключении к базе (при работе в
                    архитектуре Classic server). Этот ID (3142) легко найти в списке
                    firebird-процессов:</para>
                <synopsis>
# ps aux | grep firebird$                    
                </synopsis>
                <screen>
firebird 1635 0.0  0.0 136464  2360 ?   Sl  Dec07  0:00 /opt/firebird/bin/firebird
firebird 3142 0.0  0.1 571768 11792 ?   Sl  20:09  0:00 /opt/firebird/bin/firebird                        
                    </screen>

                <para>В строке 18 <code> Flags: 0x00</code> указан флаг состояния владельца ресурса.
                    Значение 0x00 означает отсутствие каких-либо сведений о состоянии владельца. В
                    Firebird используются следующие флаги состояний владельцев
                        (<filename>src/lock/lock_proto.h</filename>): <itemizedlist>
                        <listitem>
                            <para><code>OWN_scanned = 1</code> — владелец был проверен на
                                причастность к deadlock ("Owner has been deadlock scanned");</para>
                        </listitem>
                        <listitem>
                            <para><code>OWN_wakeup = 2</code> — к владельцу был послан сигнал
                                отпустить блокировку ("Owner has been awoken"; Borrie: "Owner has
                                been poked to release a lock");</para>
                        </listitem>
                        <listitem>
                            <para><code>OWN_signaled = 4</code> — сигнал считается доставленным
                                владельцу ("Signal is thought to be delivered").</para>
                        </listitem>
                    </itemizedlist></para>
                <para>В строке 19 <code>Requests (80) ...</code> — указаны запросы владельца на
                    блокировки (как осуществлённые, так и ожидающие).</para>
                <para>В строке 20 <code>Blocks: *empty*</code> — указаны сведения о том, сколько
                    других процессов ждёт свобождения ресурсов, занятых текущим владельцем (то есть
                    сколько других процессов блокирует текущий владелец).</para>
                <para>В строке 21 <code>Pending: *empty*</code> — указаны сведения о том, сколько
                    ресурсов занято другими процессами, но нужно текущему владельцу (т.е. сколько он
                    запросил блокировок и ждёт их предоставления).</para>
            </section>
            <section>
                <title>Данные о блокировках (LOCK BLOCK)</title>

                <para>Блокировки в лок-таблице есть визуальное представление тех ресурсов, с
                    которыми оперируют процессы (соединения).</para>

                <para>Вывод информации о блокировках осуществляется указанием ключа
                    <code>-l</code>.</para>
                <para> Каждый набор строк с этой информацией начинается с фразы <code>LOCK BLOCK
                        &lt;nnnnnn&gt;</code> Пример: <screen>
<![CDATA[                    
LOCK BLOCK 173216
        Series: 1, State: 6, Size: 0, Length: 0, Data: 0
        Key: <none> Flags: 0x00, Pending request count:      0
        Hash que (4):   forward: 173352, backward:    412
        Requests (1):   forward: 173144, backward: 173144
                Request 173144, Owner: 172960, State: 6 (6), Flags: 0x00    
]]>                
                </screen>
                </para>

                <para>Количество информации, выводимой при использовании ключа <code>-l</code>,
                    почти всегда оказывается слишком избыточным для анализа. Чтобы ограничить вывод
                    лок-таблицы только теми ресурсами, которые являются <quote>предметом
                        спора</quote>, т.е. на которых возникли ожидания, следует использовать ключ
                        <code>-n</code> как дополнение к ключу <code>-l</code>, т.е. запускать
                    утилиту так:</para>
                <synopsis>
fb_lock_print -n -l -c -d my_database                    
                </synopsis>

            </section>
            <section>
                <title>Быстрая диагностика наличия очередей к ресурсам</title>

                <para>О том, есть ли очереди вообще, можно быстро выяснить, введя команду:
                    <synopsis>
fb_lock_print -c -n -l -d my_database                        
                    </synopsis>
                    и отфильтровав её вывод по условию вхождения строки "Pending request
                    count:".</para>
                <para>Наличие строк в выводе будет говорить о том, что существуют ожидания каких-то
                    ресурсов. Последняя лексема в каждой строке (положительное число) — это
                    количество процессов, которые ждут некоторый ресурс.</para>
                <para>Пример вызова для POSIX:
                    <synopsis>
/opt/firebird/bin/fb_lock_print -c -n -l -d our_production_alias | grep -i 
  "Pending request count:"                        
                    </synopsis>
                </para>
                <para>Пример вызова для Windows:
                    <synopsis>
"c:\Program Files\Firebird\Firebird 3\fb_lock_print.exe" -c -n -l -d 
  our_production_alias | findstr /c:"Pending request count:"                        
                    </synopsis>
                </para>
                <para>Пример вывода на системе, работающей под сильной нагрузкой:</para>
                <screen>
Key: 0001:000157, Flags: 0x00, Pending request count:	1
Key: 0001:001449, Flags: 0x00, Pending request count:	26
Key: 0001:097628, Flags: 0x00, Pending request count:	1
Key: 0001:235183, Flags: 0x00, Pending request count:	1
Key: 0001:238747, Flags: 0x00, Pending request count:	15                    
                </screen>

                <para>Если сумма ожидающих соединений превышает 10% от общего числа соединений
                    (которые легко находятся в заголовке лок-таблицы поиском строки "Owners ()", то
                    это говорит о проблемах с конкурентным доступом к ресурсам базы. При превышении
                    50% проблемы можно считать уже критическими.</para>
                <para>Однако, в вышеприведенном фрагменте нет никакой информации о том, какие именно
                    ресурсы удерживаются и являются причиной ожиданий. Эти команды даны только для
                        <quote>быстрой диагностики</quote> производительности системы.</para>
            </section>
            <section>
                <title>Углубленная диагностика очередей к ресурсам</title>

                <para>Блоки с информацией о ресурсах (LOCK BLOCK) позволяют определить ТИП ОБЪЕКТА
                    базы данных, являющийся <quote>предметом спора</quote> процессов.</para>
                <para>Чаще всего это страница, хранящая счетчики генераторов, либо относящаяся к
                    данным таблицы (Data Pages, DP), указателям страниц (Pointer Pages, PP) или
                    индексу (корневая страница или страница промежуточного и/или листового уровня
                    Index Page). </para>
                <para>Могут также возникать ожидания на странице TransactionInventory Page (TIP),
                    ожидания ввиду сброса данных мониторингу и ожидания на заголовке БД.</para>

                <para>Данные об очередях к ресурсам получаются командой:</para>
                <synopsis>
    fb_lock_print -c -n -l -d our_production_alias                    
                    </synopsis>

                <para>Всё, что находится в выводе этой команды после заголовка лок-таблицы, является
                    информацией о ресурсах, к которым возникли очереди. Далее эти блоки называются
                    "лок-блоками" (LOCK BLOCK).</para>

                <para>Рассмотрим следующий пример лок-блока (строки специально пронумерованы; в
                    реальности нумерация строк отсутствует):</para>
                <screen linenumbering="numbered"><![CDATA[LOCK BLOCK 603456
    Series: 3, Parent:  21000, State: 6, size: 8 length: 8 data: 0
    Key: 0001:002017, Flags: 0x00, Pending request count:      1
    Hash que (7):    forward:  90616, backward: 659760
    Requests (2):    forward: 846960, backward: 474024
       Request 846960, Owner: 514112, State: 6 (6), Flags: 0x01
       Request 474024, Owner: 528992, State: 0 (6), Flags: 0x02]]></screen>


                <para>В строке 2: <code>Series: 3, Parent: 21000, State: 6, size: 8 length: 8 data:
                        0</code> — нас должно интересовать только число, записанное после "Series".
                    В данном примере это число равно 3. Согласно списку видов блокировок в Firebird
                    (смотри выше), этот индекс соответствует ожиданию доступа к странице базы
                    данных: (<quote>3 LCK_bdb Individual buffer block</quote>). Это может быть
                    страница, относящаяся к любому объекту: таблице, индексу, генераторам, TIP и
                    прочее.</para>

                <para>Что бы понять, к какому именно объекту относятся страничные ожидания,
                    анализируем строку 3. В начале строки 3: <code>Key: 0001:002017</code> —
                    записаны номер страничного пространства (<quote>0001</quote>) и после двоеточия
                    — номер страницы в нём (<quote>002017</quote>). Номер страничного пространства
                    для файла БД всегда равен <quote>0001</quote>. Другие значения могут быть только
                    для GTT, но по ним конкуренции не бывает.</para>

                <para>Номер страницы — всегда четырёхбайтовый и записан десятичном виде.</para>

                <important>
                    <para>Для других видов ресурсов, имеющих 8-байтные ID, визуальное представление
                        этих ID отличается от приведенного и требует дополнительного объяснения.
                        (см. следующий раздел).</para>
                </important>

                <para>Значение флагов (<code>Flags: 0x00</code>) можно игнорировать.</para>

                <para>Значение после фразы "Pending request count" есть количество процессов,
                    ожидающих блокировку на данный ресурс.</para>

                <note>
                    <para>В архитектуре SuperServer отсутствует блокировка <code>LCK_bdb</code>
                            (<quote>Individual buffer block</quote>). По этой причине диагностика
                        узких мест в помощью <application>fb_lock_print</application> в этой
                        архитектуре не применима, если целью поиска являются ожидания на страничных
                        блокировках.</para>
                </note>
            </section>

            <section>
                <title>Кодировка 8-байтных значений идентификаторов ресурсов</title>

                <para>Все ресурсы за исключением страниц базы, хранятся в лок-таблице как 8 байтовые
                    числа. <application>fb_lock_print</application> получает их в виде двоичной
                    строки, т.е. они представлены в системе счисления с основанием 256.</para>

                <para>Все символы с кодами от 0 до 64 считаются
                        <quote>потенциально-проблемными</quote> для печати и вместо них печатаются
                    их ascii-коды в угловых скобках. Например, если число содержит в своём
                    представлении символ <code>ascii_char(14)</code>, то вместо него
                        <application>fb_lock_print</application> выведет на печать: &lt;14&gt;.
                    Символы с кодами 65 и выше печатаются <quote>как они есть</quote>. Само число
                    (ID ресурса) выводится в перевернутом виде: от младших байтов к старшим.</para>

                <para>Вот пример того, как могут быть показаны ресурсы <code>LCK_attachment</code>
                    (монопольные блокировки подключениями своих attach-объектов, тип равный
                    7):</para>
                <screen>
<![CDATA[
LOCK BLOCK 1177744
        Series: 7, State: 6, Size: 8, Length: 8, Data: 0
        Key: O<14><7><3><0><0><0><0>, Flags: 0x00, Pending request count: 0
        ...

LOCK BLOCK 909776
        Series: 7, State: 6, Size: 8, Length: 8, Data: 0
        Key: K<14><7><3><0><0><0><0>, Flags: 0x00, Pending request count: 0
        ...

LOCK BLOCK 372768
        Series: 7, State: 6, Size: 8, Length: 8, Data: 0
        Key: <64><14><7><3><0><0><0><0>, Flags: 0x00, Pending request count: 0
        ...

LOCK BLOCK 424760
        Series: 7, State: 6, Size: 8, Length: 8, Data: 0
        Key: C<14><7><3><0><0><0><0>, Flags: 0x00, Pending request count: 0
        ...
]]>                  
                </screen>


                <para>В этом примере (в последнем блоке) <code>Key:
                        C&lt;14&gt;&lt;0&gt;...&lt;0&gt;</code> — это число, равное: <equation>
                        <mathphrase> ascii_char('C') * (256**0) + 14 * (256**1) + 7 * (256**2) + 3 *
                            (256**3) = 50794051 </mathphrase>
                    </equation>
                </para>
                <para>Таким образом этот лок-блок относится к подключению с connection_id = 50794051
                    (отсчет позиций ведется слева направо, крайний левый символ считается позицией
                    номер 0, крайний правый — позицией номер 7).</para>
            </section>
            <section>
                <title>Поиск объекта БД, к которому принадлежит страница с заданным номером</title>

                <para>При исследовании проблем производительности приложений необходимо выявить
                    конфликты процессов за установку блокировок на страницы: чем больше возникает
                    конфликтов из-за какого-либо ресурса, тем заметнее задержки в выполнении даже
                    тривиальных запросов к базе, достигающие иногда десятков секунд при почти
                    нулевых значениях счетчиков статистики.</para>

                <para>Особое внимание надо уделить конфликтам за страницы таблиц (DP и PP), индексов
                    и генераторов.</para>

                <para>Чтобы получить сведения о том, к какому объекту относится страница с известным
                    номером ("002017"), необходим вызов API-функции
                    <code>isc_database_info()</code>. В большинстве компонентов доступа к базам
                    Firebird (Delphi, Python, JayBird) есть возможность вызова этой функции и
                    представлена соответствующая документация.</para>

                <para>Функция заполняет данными предварительно создаваемый (клиентской стороной, то
                    есть драйвером доступа к БД) буфер, передаваемый этой функции как
                    аргумент.</para>

                <para>В первом байте этого буфера записано число — идентификатор типа
                    страницы:</para>
                <orderedlist spacing="compact">
                    <listitem>
                        <para>заголовок БД, <quote>DB header</quote>;</para>
                    </listitem>
                    <listitem>
                        <para>страница-оглавление использования остальных страниц,
                                <quote>PIP</quote>;</para>
                    </listitem>
                    <listitem>
                        <para>страница-оглавление состояний транзакций, <quote>TIP</quote>;</para>
                    </listitem>
                    <listitem>
                        <para>страница-оглавление использования страниц для хранения данных таблицы,
                                <quote>Pointer Page</quote>;</para>
                    </listitem>
                    <listitem>
                        <para>страница с данными некоторой таблицы <quote>Data Page</quote>;</para>
                    </listitem>
                    <listitem>
                        <para>корневая страница индекса некоторой таблицы, <quote>Index
                            Root</quote>;</para>
                    </listitem>
                    <listitem>
                        <para>страница индекса (промежуточного или листового уровня), <quote>B-Tree
                                Page</quote>;</para>
                    </listitem>
                    <listitem>
                        <para>страница для хранения двоичного объекта, <quote>Blob</quote>;</para>
                    </listitem>
                    <listitem>
                        <para>страница счетчиков последовательностей (генераторов),
                                <quote>Generators Page</quote>;</para>
                    </listitem>
                    <listitem>
                        <para>страница с номером последовательного изменения базы,
                                <quote>SCN</quote> (новый тип, введён в Firebird 3.0).</para>
                    </listitem>
                </orderedlist>

                <para>По типу страницы можно определить идентификатор таблицы или индекса, либо
                    принадлежность этой страницы к какому-либо классу (Generators Page, Pointer
                    Page). Эти позволит сделать вывод о том, какой именно ресурс является узким
                    местом вашего приложения.</para>
                <para>Следует помнить, однако, что за период от момента получения номера проблемной
                    страницы &lt;P> и до момента возврата из функции
                        <code>isc_database_info()</code> в базе могут быть изменения, затрагивающие
                    именно эту страницу &lt;P&gt;. В таком случае, сведения от
                        <code>isc_database_info()</code> о принадлежности страницы некоторому
                    объекту (таблице, индексу и так далее) могут оказаться неверными. Это не
                    относится к страницам DB Header и Generators Page. Также маловероятно, что будет
                    часто меняться страница, относящаяся к типу Index Root.</para>
                <para>Дальнейшее объяснение работы этой функции выходит за рамки данной
                    документации.</para>
            </section>
            <section>
                <title>Дополнительные замечания по ожиданиям страничных блокировок</title>


                <orderedlist>
                    <listitem>
                        <para>Страничные блокировки НЕ отключаются при работе транзакции с уровнем
                            изолированности SNAPSHOT TABLE STABILITY.</para>
                    </listitem>
                    <listitem>
                        <para>Страничные блокировки НЕ отключаются при работе с GTT, даже когда она
                            объявлена как ON COMMIT DELETE ROWS.</para>
                    </listitem>
                    <listitem>
                        <para>Массовый старт транзакций (например, при одновременном входе сотен
                            пользователей утром) может приводить к ожиданиям DB header (страницы с
                            номером 0).</para>
                    </listitem>
                    <listitem>
                        <para>Ожидания на страницах является обычной ситуацией, если очередь
                            составляет менее 1% от общего количества соединений. Причина в том, что
                            любая недавно прочитанная страница держит read-лок (т.к. блокировки
                            кешируются). Если далее к ней подходит процесс от писателя (например,
                            INSERT выделяет новую страницу в базе и требует отметить ее в PIP), то
                            ему требуется write-lock. Он будет ждать. Получит он его очень быстро,
                            но не мгновенно — пока будет отправлен сигнал читателю, пока тот
                            отпустит блокировку, пока просигналит обратно. Весь этот (небольшой)
                            период писатель будет в очереди pending request. И так с любой
                            страницей, не только PIP. Грубо говоря, наличие <emphasis role="bold"
                                >одного</emphasis> писателя в pending-очереди является проблемным,
                            только если он там висит достаточно долгое время (больше секунды,
                            например). Иначе это просто штатная ситуация.</para>
                    </listitem>
                </orderedlist>


                <tip>
                    <para>Если соединений всего одно, то страничные блокировки не используются. Это
                        следует учитывать, когда необходимо выполнить какие-то операции массовой
                        обработки данных. Если есть возможность сделать это в единственном
                        соединении — следует делать именно так.</para>
                </tip>
            </section>
            <section>
                <title>Поиск ID процессов, удерживающих ресурсы</title>

                <para>Для получения значений PID всех соединений, задействованных в ожидании (т.е.
                    тех, кто ждёт и того, кого ждут), следует рассмотреть строки, начиная с
                    6-й:</para>
                <screen linenumbering="numbered" startinglinenumber="6">       Request 846960, Owner: 514112, State: 6 (6), Flags: 0x01
       Request 474024, Owner: 528992, State: 0 (6), Flags: 0x02 </screen>


                <para>В этих строках показаны данные по запросам (requests), которые имеются к
                    данному ресурсу. В первой строке (в примере — строка 6) указан всегда тот, кто
                    владеет ресурсом. Для него всегда в части строки <quote>State:
                            <replaceable>N</replaceable> (<replaceable>K</replaceable>)</quote>
                    записано одно и то же число, то есть N = K. После этой строки (в примере —
                    начиная со строки 7) в списке идут те, которые ждут ресурс (они как раз и
                    считаются как <quote>pending</quote>). У них N не равно K (и обычно N меньше K).
                    Кроме того, у них взведен второй бит в значении <quote>Flags</quote>.</para>
                <para>Если из каждой строки извлечь значения Owner, то полученное число является ID
                    владельца, к которому относится данная строка. В частности, для 6-й строки мы
                    получим ID владельца блокировки 514112 — того, кого ждут остальные.</para>
                <para>Далее, в выводе <application>fb_lock_print</application> необходимо найти
                    набор строк с OWNER BLOCK, равным этому числу (514112).</para>

                <para>Наконец, в найденном блоке строк для владельца с id=514112 нужно найти строку
                    с "Process id" и извлечь из неё число. Это число (6863) будет PID процесса,
                    который удерживает ресурс.</para>
                <screen>
OWNER BLOCK 514112
    Owner id: ..., Type: 1
    Process id:   6863 (Alive), Thread id:   6871
    Flags: 0x00                    
                </screen>


                <note>
                    <para>В архитектуре Super* ID процесса всегда одинаковый и различаться могут
                        только значения thread:</para>
                    <screen>
    OWNER BLOCK 58283128
            Owner id: 14289360384590, type: 1, pending:      0
            Process id:   3327 (Alive), thread id: 140146837899008
            ...

    OWNER BLOCK 30347000
            Owner id: 14289360384593, type: 1, pending:      0
            Process id:   3327 (Alive), thread id: 140146837899008
            ...

    OWNER BLOCK 45735184
            Owner id: 14289360385472, type: 1, pending:      0
            Process id:   3327 (Alive), thread id: 140146578904832
            ...

    OWNER BLOCK 2200744
            Owner id: 14289360385781, type: 1, pending:      0
            Process id:   3327 (Alive), thread id: 140136695990016
            ...                        
                    </screen>

                    <para>При этом, потоки, существующие внутри процесса сервера, не выделяются
                        подключениям к базе навечно, а используется общий пул. Значение после фразы
                            <quote>thread: id:</quote> — ID потока, который последним обслуживал это
                        подключение.</para>
                </note>
            </section>
            <section>
                <title>Поиск ID подключения к БД, удерживающего ресурсы</title>

                <para>Чтобы выяснить идентификатор подключения, который удерживает страницу,
                    необходимо вызвать <application>fb_lock_print</application> с ключами
                        <code>-o</code>, <code>-l</code>, но БЕЗ ключа <code>-n</code>, то есть
                    потребовать вывода всех блоков, а не только pending. </para>
                <orderedlist>
                    <listitem>
                        <para>в LOCK BLOCK'e ресурса, который сейчас занят, находим ID владельца,
                            который получил ранее блокировку на этот ресурс (в предыдущем примере —
                                <quote>Owner: 514112</quote>). Для ФБ, работающего в архитектуре
                            SuperClassic, ID владельца всегда будет одинаковым. Для архитектуры
                            Classic это будет PID процесса, созданного для работы данного
                            подключения к базе.</para>
                    </listitem>
                    <listitem>
                        <para>найти в логе такой LOCK BLOCK с типом <quote>Series: 7</quote>, у
                            которого в строке, задающей request, будет этот же Owner (514112), а
                            также выполнено требование: в строке <quote>State:
                                    <replaceable>N</replaceable>
                                (<replaceable>K</replaceable>)</quote> оба значения N и K —
                            одинаковые числа:</para>
                        <screen>
LOCK BLOCK 174056
      Series: 7, State: 6, Size: 8, Length: 8, Data: 0
      Key: 000000035, Flags: 0x00, Pending request count:      0
      Hash que (3):   forward: 174200, backward:  21972
      Requests (1):   forward: 173984, backward: 173984
      Request 173984, Owner: 514112, State: 6 (6), Flags: 0x00                                
                            </screen>

                    </listitem>
                    <listitem>
                        <para>строка с <code>Key: 000000035, Flags: 0x00, ...</code> — показывает в
                            Key-поле идентификатор подключения. Идентификатор подключения выводятся
                            в десятичном виде, с ведущими нулями. В данном примере идентификатор
                            подключения — десятичное число 35.</para>
                    </listitem>
                </orderedlist>
            </section>
            <section>
                <title>Поиск транзакции, удерживающей ресурсы</title>

                <para>Чтобы выяснить номер транзакции, которая удерживает ресурс (например, она
                    позволяет вставить значение в уникальный индекс, так как сама вставила его
                    только что, но не подтвердилась и не отменилась), следует вызвать лок-таблицу с
                    ключами <code>-o</code>, <code>-l</code>, но БЕЗ ключа <code>-n</code>, то есть
                    потребовать вывода всех блоков, а не только pending.</para>
                <orderedlist>
                    <listitem>
                        <para>в LOCK BLOCK'e ресурса, который сейчас занят, находим ID владельца,
                            который получил ранее блокировку на этот ресурс (пусть это будет
                                <quote>Owner: 186312</quote>).</para>
                    </listitem>
                    <listitem>
                        <para>найти в логе такой LOCK BLOCK с типом <quote>Series: 4</quote>, у
                            которого в строке, задающей request, будет этот же Owner (186312), а
                            также выполнено требование: в строке <quote>State:
                                    <replaceable>N</replaceable>
                                (<replaceable>K</replaceable>)</quote> оба значения N и K —
                            одинаковые числа.</para>
                        <screen>
LOCK BLOCK 199312
        Series: 4, State: 6, Size: 8, Length: 8, Data: 183
        Key: 000000192, Flags: 0x00, Pending request count:      2
        Hash que (1):        forward: 137180, backward: 137180
        Requests (3):        forward: 198592, backward: 219736
                  Request 198592, Owner: 186312, State: 6 (6), Flags: 0x00 &lt;&lt;&lt;
                  Request 208408, Owner: 208608, State: 0 (3), Flags: 0x22
                  Request 219736, Owner: 172960, State: 0 (3), Flags: 0x02                                
                            </screen>

                    </listitem>
                    <listitem>
                        <para>строка с <code>Key: 000000192, Flags: 0x00</code> — показывает в
                            key-поле значение номера транзакции, записанное в десятичном виде, с
                            ведущими нулями, которая удерживает ресурс, ожидаемый двумя другими
                            процессами (208608 и 172960).</para>
                    </listitem>
                </orderedlist>
                <tip>
                    <para>Вызов утилиты <application>fb_lock_print</application> БЕЗ указания
                        ограничить вывод только pending-блоками (т.е. без ключа <code>-n</code>)
                        приводит к большому размеру лога. Если нужно найти в это логе строки,
                        относящиеся к pending-блокировкам, воспользуйтесь следующей командой:</para>
                    <itemizedlist>
                        <listitem>
                            <para>В POSIX
                                <synopsis>
/opt/firebird/bin/fb_lock_print -c -l -d our_production_alias | 
  grep -i "Pending request count:" | grep -v -E "count:[[:space:]]+0$"                                    
                                </synopsis>
                            </para>
                        </listitem>
                        <listitem>
                            <para>В Windows
                                <synopsis>
"c:\Program Files\Firebird\Firebird 3\fb_lock_print.exe" -c -l -d 
  our_production_alias | findstr /c:"Pending request count:" | 
  findstr /v /e /c:" 0" /c:"	0"                                        
                                    </synopsis>
                            </para>
                            <para>Ключ /c:"..." употребляется дважды; во втором его вхождении внутри
                                двойных кавычек перед 0 указан символ табуляции.</para>
                        </listitem>
                    </itemizedlist>
                </tip>
            </section>
        </section>
        <section>
            <title>Журналирование изменений счетчиков</title>

            <section>
                <title>Описание интерактивного режима</title>

                <para>Утилита <application>fb_lock_print</application> допускает возможность запуска
                    в режиме, называемом <quote>интерактивный</quote>, при котором собирается
                    информация в течение задаваемого периода. Можно задать значение интервала
                    опросов, общий период (длительность) наблюдения, а также ту группу сведений,
                    которая сейчас интересна.</para>
                <para>Чтобы запустить <application>fb_lock_print</application> в таком режиме,
                    необходимо:</para>
                <orderedlist>
                    <listitem>
                        <para>указать ключ <code>-i*</code>, где вместо символа <quote>*</quote>
                            должна быть проставлена одна из следующих букв:</para>
                        <itemizedlist spacing="compact">
                            <listitem>
                                <para>a — для логирования запросов мьютексов (блокировок самой
                                    лок-таблицы), количества блокирующих состояний и т.д.</para>
                            </listitem>
                            <listitem>
                                <para>o — для логирования количеств операций, относящихся к
                                    блокировкам (запросы на установку, преобразования, понижения
                                    уровней и т.д.)</para>
                            </listitem>
                            <listitem>
                                <para>t — для логирования операций, связанных с наиболее важными
                                    видами ресурсов</para>
                            </listitem>
                            <listitem>
                                <para>w — для логированик количеств ожиданий, таймаутов,
                                    deadlock-проверок и т.д.</para>
                            </listitem>
                        </itemizedlist>
                    </listitem>
                    <listitem>
                        <para>указать после <code>-i*</code> еще два аргумента, являющихся целыми
                            числами:</para>
                        <orderedlist numeration="arabic" inheritnum="inherit">
                            <listitem>
                                <para>интервал опроса лок-таблицы, секунд;</para>
                            </listitem>
                            <listitem>
                                <para>общее количество секунд, в течение которых следует делать
                                    опросы, по истечение которого — завершить цикл.</para>
                            </listitem>
                        </orderedlist>
                    </listitem>
                    <listitem>
                        <para>НЕ указывать ключ <code>-c</code>, т.е. запускать сбор сведений в
                            режиме, допускающем изменение лок-таблицы. Интерактивный режим
                                (<code>fb_lock_print -i ...</code>) работает только с глобальными
                            счетчиками, а не со списками объектов, поэтому в бесконечный цикл он
                            войти не может;</para>
                    </listitem>
                </orderedlist>
                <para>При выводе данных утилита автоматически добавляет слева столбец с текущим
                    временем сервера. Точность — целые секунды.</para>
                <para>Можно указывать сразу несколько ключей-модификаторов <code>-i</code>,
                    например: <code>-iat</code>. По умолчанию используются все 4 модификатора, то
                    есть запуск с ключом <code>-i</code> будет равносилен указанию:
                        <code>-iaotw</code>.</para>
            </section>
            <section>
                <title>Примеры запуска и вывода</title>


                <orderedlist>
                    <listitem>
                        <para><code>-ia</code>: логирование запросов мьютексов (блокировок самой
                            лок-таблицы), количества блокирующих состояний и так далее </para>
                        <synopsis>
/opt/firebird/bin/fb_lock_print -d some_test_db -ia 1 9999                            
                         </synopsis>
                        <screen>
11:49:27 acquire/s acqwait/s  %acqwait acqrtry/s rtrysuc/s 
11:49:28     56126     14201        25     13273         0 
11:49:29     54821     14343        26     13315         0 
11:49:30     57860     15409        26     14298         0 
11:49:31     50043     14316        28     13101         0 
11:49:32     52248     11569        22     10725         0 
11:49:33     67745     19721        29     18262         0 
...                                    
                                </screen>

                        <para>Обозначения столбцов (все числа являются средними значениями за 1
                            секунду):</para>
                        <itemizedlist spacing="compact">
                            <listitem>
                                <para>acquire/s — попытки заблокировать лок-таблицу;</para>
                            </listitem>
                            <listitem>
                                <para>acqwait/s — попытки установить блокировки на лок-таблицу,
                                    отправленные в ожидание;</para>
                            </listitem>
                            <listitem>
                                <para>%acqwait — процент попыток установить блокировки на
                                    лок-таблицу, отправленных в ожидание (т.е. mutex wait);</para>
                            </listitem>
                            <listitem>
                                <para>acqrtry/s — попытки установить блокироку на лок-таблицу,
                                    происходившие после spin-ожидания (см. выше описание Spin count
                                    - значение LockAcquireSpins из файла конфигурации)</para>
                            </listitem>
                            <listitem>
                                <para>rtrysuc/s — успешные попытки установки блокировки на
                                    лок-таблицу, когда блокировка была взята до исчерпания заданного
                                    лимита попыток (число успешных spin-циклов), в секунду</para>
                            </listitem>
                        </itemizedlist>
                    </listitem>
                    <listitem>
                        <para><code>-io</code>: логирования количеств операций, относящихся к
                            блокировкам (установка/преобразование/понижение):</para>
                        <synopsis>
/opt/firebird/bin/fb_lock_print -d some_test_db -io 1 9999                                    
                                </synopsis>
                        <screen>
11:49:15 enqueue/s convert/s downgrd/s dequeue/s readata/s wrtdata/s qrydata/s 
11:49:25     26219       519      5327      9677         9         1         0 
11:49:26     30784      1087      5981     12281        13         3         0 
11:49:27     19895       325      4587      6964         7         0         0 
11:49:28     25142       446      4538      9940        10         0         0 
11:49:29     25867       400      4797      8972        12         0         0 
11:49:30     24779       293      5601      9955        12         4         0 
...                                    
                                </screen>

                        <para>Обозначения столбцов (все числа являются средними значениями за 1
                            секунду):</para>
                        <itemizedlist spacing="compact">
                            <listitem>
                                <para>enqueue/s — запросы на установку блокировок (см. заголовок
                                    лок-таблицы, фразу <quote>Enqs: NN</quote>)</para>
                            </listitem>
                            <listitem>
                                <para>convert/s — изменения статуса блокировки (см заголовок
                                    лок-таблицы, фразу <quote>Converts: N</quote>)</para>
                            </listitem>
                            <listitem>
                                <para>downgrd/s — понижения уровня блокировки</para>
                            </listitem>
                            <listitem>
                                <para>dequeue/s — освобождения блокировок</para>
                            </listitem>
                            <listitem>
                                <para>readata/s — операции чтения данных, ассоциированных с
                                    блокировкой</para>
                            </listitem>
                            <listitem>
                                <para>wrtdata/s — операции записи данных, ассоциированных с
                                    блокировкой</para>
                            </listitem>
                            <listitem>
                                <para>qrydata/s — операции поиска данных, ассоциированных с
                                    блокировкой</para>
                            </listitem>
                        </itemizedlist>
                    </listitem>
                    <listitem>
                        <para><code>-it</code>: логирование операций, связанных с наиболее важными
                            видами ресурсов:</para>
                        <synopsis>
/opt/firebird/bin/fb_lock_print -d some_test_db -it 1 9999                                
                            </synopsis>
                        <screen>
11:49:45   dblop/s  rellop/s pagelop/s tranlop/s relxlop/s idxxlop/s misclop/s 
11:49:46         0       155     24165      1003         0        28     24826 
11:49:47         0        90     21585       457         0        19     15965 
11:49:48         0        43     18171      1535         0         8     15023 
11:49:49         0       116     24290       363         0        34     18248 
...                                    
                                </screen>

                        <para>Обозначения столбцов (все числа являются средними значениями за 1
                            секунду):</para>
                        <itemizedlist spacing="compact">
                            <listitem>
                                <para>dblop/s — блокировка на базу данных (LCK_database)</para>
                            </listitem>
                            <listitem>
                                <para>rellop/s — блокировки на таблицы (relllop = RELation Lock
                                    OPeration)</para>
                            </listitem>
                            <listitem>
                                <para>pagelop/s — блокировки страницы БД (LCK_bdb)</para>
                            </listitem>
                            <listitem>
                                <para>tranlop/s — блокировки объекта транзакций тем, кто её
                                    стартовал (LCK_tra)</para>
                            </listitem>
                            <listitem>
                                <para>relxlop/s — блокировки для защиты существования таблицы
                                    (LCK_rel_exist)</para>
                            </listitem>
                            <listitem>
                                <para>idxxlop/s — блокировки для защиты существования индекса
                                    (LCK_idx_exist)</para>
                            </listitem>
                            <listitem>
                                <para>misclop/s — прочие виды блокировок</para>
                            </listitem>
                        </itemizedlist>
                    </listitem>
                    <listitem>
                        <para><code>-iw</code>: логирование количеств ожиданий, таймаутов,
                            deadlock-проверок и так далее:</para>
                        <synopsis>
/opt/firebird/bin/fb_lock_print -d some_test_db -iw 1 9999                                
                            </synopsis>
                        <screen>
11:49:55    wait/s  reject/s timeout/s blckast/s  wakeup/s dlkscan/s deadlck/s 
11:49:56      5291       325         0      5686      7381         0         0 
11:49:57      2714       171         0      2939      3947         0         0 
11:49:58      4544       556         0      4912      6323         0         0 
11:49:59      4942      1393         0      5292      6708         0         0 
11:50:00      3841       248         0      4128      5678         0         0 
...                                    
                                </screen>

                        <para>Обозначения столбцов (все числа являются средними значениями за 1
                            секунду):</para>
                        <itemizedlist spacing="compact">
                            <listitem>
                                <para>wait/s — ожиданий на получение блокировки</para>
                            </listitem>
                            <listitem>
                                <para>reject/s — отказы (см заголовок лок-таблицы, фразу "Rejects:
                                    N")</para>
                            </listitem>
                            <listitem>
                                <para>timeout/s — отказов в получении блокировки в связи с
                                    таймаутом</para>
                            </listitem>
                            <listitem>
                                <para>blckast/s — факты блокировка кем-либо ресурсов (см заголовок
                                    лок-таблицы, фразу <quote>Blocks: N</quote>)</para>
                            </listitem>
                            <listitem>
                                <para>wakeup/s — сигналы, доставленных владельцам, которые
                                    блокировали ресурсы</para>
                            </listitem>
                            <listitem>
                                <para>dlkscan/s — изменения в значении Deadlock scans</para>
                            </listitem>
                            <listitem>
                                <para>deadlck/s — изменения в значении Deadlocks</para>
                            </listitem>
                        </itemizedlist>
                    </listitem>
                </orderedlist>

                <para>В конце работы этот режим выводит на отдельной строке среднее арифметическое
                    по каждому числовому столбцу. Пример:</para>
                <synopsis>
/opt/firebird/bin/fb_lock_print -d some_test_db -io 1 9999                    
                </synopsis>
                <screen>
11:49:15 enqueue/s convert/s downgrd/s dequeue/s readata/s wrtdata/s qrydata/s 
11:49:16     31145       615      5999     10962         8         2         0 
11:49:17     24769       660      3839      8437         6         1         0 
...
Average:     27236       479      5738     10151         8         1         0                         
                    </screen>

            </section>
        </section>
    </section>

    <section xml:id="using-trace">
        <info>
            <title>Использование Firebird Trace API</title>
        </info>
        <section>
            <title>Трассировка. Вводная информация. Зачем это нужно?</title>

            <para>Под трассировкой активности, происходящей в базе под управлением в СУБД Firebird,
                понимается регистрация событий, которые происходят ввиду создания подключений,
                старта и завершения транзакций, явных действий пользователей или некоторых системных
                процессов (на сегодня это процесс sweep).</para>
            <para>Трассировка является незаменимым средством при поиске узких мест приложения,
                оценке ресурсов, затрачиваемых при выполнении запросов, выяснении частоты каких-либо
                действий, а также для целей безопасности (накопление сведений об отклонённых
                попытках регистрации в БД).</para>
            <para>Трассировка показывает статистику в максимально детализированном виде (в отличие
                от статистике доступной например в ISQL). В статистике не учитываются затраты на
                подготовку запроса и передачу данных по сети, что делает её <quote>чище</quote>, чем
                данные, которые показывает ISQL.</para>
            <para>Трассировка оказывает очень незначительное влияние на производительность. Даже при
                интенсивной записи в журнал, речь обычно идет не более чем о 2-3% падения скорости
                выполняемых запросов. Это совершенно не так при выполнении запросов к таблицам
                мониторинга, которые могут привести сильно нагруженную систему в состояние ступора. </para>
            <para>Трассировку можно достаточно гибко настроить. В отличие от мониторинга,
                заставляющего все подключения сбрасывать всю информацию, независимо от того, что
                записано в запросе к mon$-таблицам, трассировка позволяет регистрировать только те
                виды событий, которые нам интересны (например, только ошибки времени выполнения, или
                только факты регистрации пользователей). Кроме того, трассировка позволяет указать
                минимальный порог длительности выполнявшихся запросов, и всё, что длилось меньше,
                регистрироваться не будет. Трассировка позволяет применять фильтры на выражения, по
                принципу включаемости и исключения, что дает возможность отследить только те
                запросы, которые отвечают известным нам шаблонам.</para>
            <para>Трассировка <quote>скрытна</quote>: пользовательское подключение не может
                выяснить, отслеживается ли его активность или нет. Также, у пользователей (даже
                SYSDBA) в Firebird нет средств для предотвращения трассировки их подключений
                администратором. Однако, SYSDBA может увидеть все запущенные пользовательские сессии
                трассировки, и остановить их.</para>
            <para>Наконец, на одной машине можно запускать несколько сеансов трассировки и они будут
                работать независимо, со своими настройками и направлением вывода в разные
                журналы.</para>
            <para>Всё это делает трассировку одним из самых полезных инструментов администратора и
                разработчика БД.</para>
        </section>
        <section>
            <title>Виды отслеживаемой активности. Пользовательский трассировка и системный
                аудит</title>
            <para>Отслеживание активности может происходить двумя способами:</para>
            <orderedlist>
                <listitem>
                    <para>Запуском консольного приложения с возможностью его остановки в любое
                        время. Этот вариант работы называется <quote>пользовательский
                            трассировка</quote>. Аварийное завершение работы машины, на которой
                        запущен такая трассировка, либо потеря связи с сервером (при удаленном
                        запуске) приведет к прекращению работы трассировки. Пользовательский
                        трассировка запускается Firebird-утилитами
                            <application>fbsvcmrg</application> или
                            <application>fbtracemgr</application> (вторая является
                            <quote>обёрткой</quote> над первой и предназначена для более краткого
                        формата запуска).</para>
                </listitem>
                <listitem>
                    <para>Изменением конфигурации Firebird так, чтобы трассировка стартовал
                        автоматически при каждом запуске СУБД. Такой вариант работы называется
                            <quote>системный аудит</quote>. Отслеживание запускается независимо от
                        пользователей, и его функционирование зависит только от работоспособности
                        машины сервера.</para>
                </listitem>
            </orderedlist>
            <para>Функционально оба варианта одинаковы, но предназначение у них разное.</para>
            <para>Пользовательский трассировка требуется чаще. Она позволяет быстро запустить
                трассировку, дать ей поработать и остановить её для проведения анализа и принятия
                решений. Обычно анализ журнала трассировки занимает не более одного дня.</para>
            <para>Системный аудит предназначен для "сквозной регистрации" всех интересующих событий
                и, как правило, он запускается на длительный срок. Системный аудит нельзя остановить
                иначе, кроме как отключив всех пользователей от БД. Возможное применение системного
                аудита — непрерывное отслеживание попыток регистрации путем подбора паролей, либо
                отслеживание активности, которая приводит к возбуждению каких-то заранее известных
                исключений в режиме выполнения.</para>
            <para>Существует также отличие в реализации пользовательского трассировки и системного
                аудита, которое надо учитывать. Процесс записи журнала пользовательской трассировки
                — это асинхронный процесс. Если диск не успевает справиться с большим потоком
                информации от пользовательской трассировки, то ожидания готовности диска не будет,
                работа трассировки при этом не остановится. Системный аудит, наоборот, требует
                синхронную запись на диск, при которой возможны ожидания готовности диска к приему
                очередной порции данных.</para>

            <important>
                <para>Системный аудит может привести к созданию журнала с очень большим размером
                    (десятки гигабайт), поэтому необходимо обязательно убедиться, что на
                    соответствующем диске достаточно места для такого журнала.</para>
            </important>
            <para>Остановка пользовательского трассировки может быть выполнена либо интерактивно, то
                есть нажатием сочетания клавиш Ctrl-C, либо вводом команды
                    <application>fbsvcmgr</application> (или <application>fbtracemgr</application>)
                с передачей ей специального аргумента: <code>action_trace_stop trc_id
                    &lt;N&gt;</code> — что приведет к остановке трассировки без интерактивного
                вмешательства пользователя.</para>
            <para>Управление пользовательской трассировкой можно проводить как на самом сервере, где
                работает экземпляр Firebird, так и с другой машины, на которой установлен Firebird.
                При этом следует указывать IP-адрес удаленного сервера, порт прослушивания (3050 или
                другой), имя менеджера сервисов ('service_mgr') и команду, которую он должен
                выполнить (для запуска это <code>action_trace_start</code>). Примеры команд
                управления пользовательской трассировкой будут показаны ниже.</para>
            <para>Остановка системного аудита, работающего независимо от какой-либо из клиентских
                машин, возможно только через рестарт процесса Firebird (с изменением файла
                    <filename>firebird.conf</filename>, которое предотвратит новый старт
                аудита).</para>
        </section>
        <section>
            <title>Блочное представление информации</title>
            <para>События выводятся в виде простого текста, и каждое из них начинается с указания
                штампа даты-времени, за которым в скобках следует служебная информация, после чего —
                мнемоническое обозначение самого события:</para>
            <screen>
    2017-12-04T13:16:47.8760 (25101:0x7f5e13868890) EXECUTE_STATEMENT_FINISH            
        </screen>
            <para>Реальная точность значений времени сервера — до миллисекунд.</para>
            <para>Все отслеживаемые события, за исключением сообщений о старте/финише сессий
                трассировки, имеют заголовочную информацию позволяющую идентифицировать, что за
                событие произошло, успешно ли оно завершилось (если речь идет об итоге чего-либо),
                какое приложение работало при этом, в какой именно базе данных это произошло, какие
                были ID у соединения и транзакции и другое.</para>
            <para>Таким образом, значительная часть информации в логе трассировки выглядит в каждом
                блоке одинаково. Например, в следующем фрагменте трассировки:</para>
            <screen linenumbering="numbered"><![CDATA[2017-12-04T13:16:47.8760 (25101:0x7f5e13868890) EXECUTE_STATEMENT_FINISH
        production (ATT_41396268, JOHN:MANAGER, WIN1251, TCPv4:172.16.6.31)
        C:\App\stock_info.exe:1628
                (TRA_393161255, READ_COMMITTED | REC_VERSION | WAIT | READ_ONLY)

Statement 499122858:
-------------------------------------------------------------------------------
select ...
from ...


2017-12-04T13:16:47.9950 (25101:0x7f5e1386c390) EXECUTE_STATEMENT_FINISH
        production (ATT_41396249, MARY:ACCOUNTANT, WIN1251, TCPv4:172.16.6.31)
        C:\App\finance_garant:1604
                (TRA_393161257, READ_COMMITTED | REC_VERSION | WAIT | READ_ONLY)

Statement 499122478:
-------------------------------------------------------------------------------
select ...
from ...            
]]></screen>
            <para>Видно, что строки, с номерами 1...4 и 12...15 имеют одинаковую структуру и
                содержат одинаковые теги для событий ('EXECUTE_STATEMENT_FINISH'), имени базы или её
                алиаса ('production'), ID подключения ('ATT_nnnnnnn'), и так далее.</para>
            <para>Недостаток у такого представления информации только один: избыточность. Но он
                перевешивается простотой визуального анализа журнала (лога): всё сосредоточено
                рядом, чаще всего нет необходимости в пролистывании лога вверх для получения
                дополнительных сведений.</para>
            <para>Кроме того: если каждое событие начинается одинаковым набором строк, то несложно
                написать скрипт для такой обработки трассировки, при котором все сведения о каждом
                событии (заголовок, текст SQL-запроса, статистика) будут рассматриваться как
                неделимые БЛОКИ. Это позволит затем переупорядочивать блоки и выводить информацию
                    <quote>поблочно</quote>, в нужном нам виде, например — в порядке убывания
                длительности выполнения операторов. Это позволит сразу получать перечень
                    <quote>узких мест</quote> в производительности приложения.</para>
        </section>
        <section>
            <title>Краткое описание работы. Типичный сценарий работы DBA</title>
            <para>Чтобы запустить трассировку, нужно сначала подготовить текстовый файл
                конфигурации, аналогичный <filename>firebird.conf</filename> (он также содержит пары
                вида: <quote>параметр = значение</quote>).</para>
            <para>Конфигурационный файл допускает указывать параметры для ФИЛЬТРАЦИИ таких
                категорий, как виды событий, длительность выполнения, печать плана, печать
                статистики, перечень кодов ошибок, перечень регулярных выражений — шаблонов для
                проверки на соответствие выполняемым SQL-выражениям, и другое.</para>
            <para>Фильтрация видов событий выполняется просто: нужно присвоить соответствующему
                параметру значение true.</para>
            <para>Фильтрация длительности выполнения запросов выполняется назначением минимального
                порога длительности (в миллисекундах). Все запросы, длящиеся выше этого значения
                    (<quote>медленные</quote>), будут рассматриваться на возможность их включения в
                лог трассировки. Все остальные запросы (<quote>быстрые</quote>) будут
                отбрасываться.</para>
            <para>Фильтрация кодов ошибок и отслеживаемых шаблонов выполняемых выражений выполняется
                по принципу проверки одному и/или двум задаваемым регулярным выражениям.</para>
            <itemizedlist>
                <listitem>
                    <para>Включающий фильтр. Работает по принципу допускаются только те, что
                        соответствуют регулярному выражению;</para>
                </listitem>
                <listitem>
                    <para>Исключающий фильтр. Работает по принципу допускаются все, за исключением
                        тех, что соответствуют регулярному выражению.</para>
                </listitem>
            </itemizedlist>
            <para>Более подробно виды фильтрации будут рассмотрены далее в примерах.</para>
            <para>Типичный сценарий работы с трассировки — следующий:</para>
            <orderedlist>
                <listitem>
                    <para>Создается текстовый файл конфигурации для пользовательской
                        трассировки:</para>
                    <orderedlist numeration="arabic" inheritnum="inherit">
                        <listitem>
                            <para>Проверяется шаблон заголовочной строки (<code>database =
                                    ...</code>). Этот шаблон должен удовлетворять правилам SIMILAR
                                TO (см. далее).</para>
                        </listitem>
                        <listitem>
                            <para>Особое внимание в нем уделяется параметру
                                    <parameter>time_threshold</parameter>, который оказывает самое
                                сильное влияние на размер лога трассировки.</para>
                        </listitem>
                        <listitem>
                            <para>Включается параметр регистрации завершения SQL-выражений:
                                    <code>log_statement_finish = true</code>.</para>
                        </listitem>
                        <listitem>
                            <para>Включается параметр показа табличной статистики: <code>print_perf
                                    = true</code>.</para>
                        </listitem>
                        <listitem>
                            <para>Включается параметр показа плана выполнения: <code>print_plan =
                                    true</code> (или <code>explain_plan = true</code>).</para>
                        </listitem>
                    </orderedlist>
                </listitem>
                <listitem>
                    <para>Запускается пользовательская трассировка с обязательным перенаправлением
                        его вывода в лог. Длительность работы — например, 5 минут.</para>
                </listitem>
                <listitem>
                    <para>По окончании работы трассировки останавливается.</para>
                </listitem>
                <listitem>
                    <para>Проводится анализ лога трассировки на предмет наличия в нём SQL-выражений,
                        который выполнялись дольше всего. Если имеется скрипт/программа для
                            <quote>блочного преобразования</quote> текста лога трассировки, то её
                        результатом должен быть тот же самый трассировки, но в нем самыми первыми
                        должны быть SQL-запросы с максимальной длительностью.</para>
                </listitem>
            </orderedlist>
        </section>
        <section>
            <title>Пользовательская трассировка и аудит: настройка, запуск и остановка</title>

            <para>До запуска трассировку надо настроить посредством редактирования текстового файла
                со строками вида "параметр = значение". Если запускается пользовательская
                трассировка, то имя этого файла затем передается в строку-команду как значение
                одного из ключей. Если же запускается системный аудит, то имя этого файла
                прописывается в <filename>firebird.conf</filename> в качестве значения параметра
                    <parameter>AuditTraceConfigFile</parameter>.</para>
            <para>Создаваемый файл конфигурации должен содержать параметр <code>enabled =
                    true</code>, чтобы трассировка или аудит смог начать выводить сообщения. В
                противном случае, все параметры файла конфигурации считаются выключенными и никаких
                сообщений в логе трассировки не будет. Этот параметр (<code>enabled = true |
                    false</code>) полезен, когда нужно временно запретить трассировке активность, но
                отменить его запуск нежелательно. По умолчанию параметр установлен в false, т.е. все
                прочие параметры будут считаться выключенными и трассировка при запуске не выдаст
                ничего. </para>
            <orderedlist>
                <listitem>
                    <para>Запуск пользовательского трассировке происходит так (путь к каталогу
                        Firebird — в нотации POSIX):</para>
                    <screen>
<![CDATA[
/opt/firebird/bin/fbsvcmgr localhost/3050:service_mgr action_trace_start 
  trc_cfg <подготовленная_trace_конфигурация.conf>
]]>                        
                    </screen>

                    <para>В этот момент на консоль или в лог будет выдано сообщение о том, какой
                        номер присвоен только что запущенной сессии трассировки. Этот номер важен,
                        если далее планируется корректная остановка именно <quote>нашей</quote>
                        сессии. Номер сессии трассировки можно получить и с помощью отдельной
                        команды, это делается так:</para>
                    <screen>
/opt/firebird/bin/fbsvcmgr localhost/3050:service_mgr action_trace_list                        
                    </screen>

                    <para>Однако, эту команду следует вводить как можно быстрее после предыдущей,
                        чтобы уменьшить шансы получения <quote>чужого</quote> номера. Когда
                        трассировку надо остановить, следует использовать команду:</para>
                    <screen>
/opt/firebird/bin/fbsvcmgr localhost/3050:service_mgr action_trace_stop trc_id <replaceable>&lt;N&gt;</replaceable>                        
                    </screen>
                    <para>— где <replaceable>&lt;N&gt;</replaceable>; есть номер
                            <quote>нашей</quote> trace-сессии, полученный ранее. </para>
                </listitem>
                <listitem>
                    <para>Запуск системного аудита, как отмечалось выше, происходит автоматически
                        при рестарте Firebird. Его нельзя запустить <quote>вручную</quote>.
                        Аналогично, для остановки аудита требуется остановить Firebird и сделать
                        пустым (или закомментировать) значение параметра
                            <parameter>AuditTraceConfigFile</parameter> в
                            <filename>firebird.conf</filename> (см. также здесь:<link
                            xlink:href="https://www.firebirdsql.org/file/documentation/release_notes/html/ru/rlsnotes25.html#rnfb25-fbconf-audit"
                            >AuditTraceConfigFile</link>).</para>
                </listitem>
            </orderedlist>

            <note>
                <para>Администратор может запустить любое количество пользовательских сессий
                    трассировки, с любыми конфигурационными файлами. Более того, запустить
                    трассировку в Firebird 3.0 может любой пользователь, но видеть он будет только
                    активность своей учетной записи.</para>
            </note>
        </section>

        <section>
            <title>Структура конфигурации. Проверка имен на соответствие шаблонам</title>

            <orderedlist>
                <para>Наиболее важным в конфигурации трассировки является параметр-заголовок
                        <quote>database</quote>, строковое значение которого задает ДВЕ группы
                    шаблонов:</para>
                <listitem>
                    <para>шаблоны каталогов и имен файлов баз, далее назовем эту группу G1 и</para>
                </listitem>
                <listitem>
                    <para>шаблоны алиасов БД для подключения, далее назовем эту группу G2.</para>
                </listitem>
            </orderedlist>
            <para>Решение о том, отражать ли активность в некоторой базе (или её алиасе) с именем X,
                принимается прежде всего по результату проверки на соответствие имени X хотя бы
                одному шаблону из этих двух групп: G1 или G2. Соответствие проверяется по тем же
                принципам, которые используются в работе SQL-оператора SIMILAR TO, но при этом не
                учитывается регистр символов.</para>
            <para>В конфигурационном файле трассировки может быть произвольное количество
                database-секций.</para>
            <para>При выполнении подключения к какой-то базе файл перечитывается каждый раз заново,
                с первой строки и до тех пор, пока имя базы данных или её псевдоним не будут
                соответствовать какому-либо из шаблонов. Пройденная проверка шаблона означает, что
                начинают применяться ТОЛЬКО те параметры, что указаны в секции внутри фигурных
                скобок.</para>
            <para>Все секции, расположенные ниже той, где прошла проверка шаблона, для данного файла
                БД/алиаса уже не действуют.</para>
            <para>Самая последняя секция из указываемых в файле конфигурации может не иметь шаблона
                и выглядеть так:</para>
            <programlisting>
database = 
{
    <replaceable>&lt;params&gt;</replaceable> ...
}                
            </programlisting>

            <para>Эта секция служит для применения её параметров ко всем файлам БД/алиасам, по
                которым еще не было найдено соответствий шаблонам, указанным в файле конфигурации
                ВЫШЕ данной строки.</para>
            <para>Объяснить структуру файла будет проще на следующем примере.</para>
            <programlisting>
<![CDATA[
# P1 — шаблон проверки имён тех БД/алиасов, отслеживание активности 
# в которых нас не интересует
database = <P1> 
{ 
   enabled = false 
}

# P2 — шаблон для тех БД/алиасов, в которых нас интересуют только 
# события отклоненных попыток регистрации
database = <P2> 
{
   enabled = true
   log_connections = true
   log_errors = true
}

database = <P3> 
# P3 - шаблон только для тех БД алиасов, в которых нам интересно выполнение 
# выражений над таблицей "some_very_huge_table",
# причём длительность выполнения должна быть не менее 5000 мс.
{
    enabled = true
    time_threshold = 5000
    log_statement_finish = true
    include_filter = "%((from|join)[[:WHITESPACE:]]+some_very_huge_table)%"
}

database =
# Нет шаблонов после знака "=". Это означает: все прочие имена файлов 
# БД/алиасов, которые не попали на соответствие в шаблонах,
# указанных выше этой строки: P1, P2 и P3.
{
    enabled = true
    time_threshold = 1000
    log_statement_finish = true
    log_procedure_finish = true
    log_function_finish = true
    exclude_filter = "%(execute[[:WHITESPACE:]]+block[[:WHITESPACE:]]+as)%"
}
]]>             
            </programlisting>

            <para>Работающий пример с конкретными шаблонами: <programlisting>
<![CDATA[
# Запрещаем регистрацию любой активности, которая происходит 
# в базе учетных записей пользователей и паролей
database = (%[\\/](security3).fdb|(security.db))
{
    enabled = false
}

# Разрешаем регистрацию ошибок — и только их — в базе с секретными сведениями.
# Прочих разрешений (например, показ выполняемых SQL-выражений) — нет:
database = (%[\\/](top_secret).fdb|(secret_alias))
{
    enabled = true
    log_initfini = false
    log_errors = true
}

# Для базы, работающей под интенсивной нагрузкой, разрешаем 
# регистрацию SQL-выражений любой длительности, но только тех,
# которые относятся к таблицам мониторинга.
database = (%[\\/](heavy_production).fdb|(heavy_prod_alias))
{
    enabled = true
    log_initfini = false
    log_errors = false
    time_threshold = 0
    log_statement_finish = true
    include_filter = "%((from|join)[[:WHITESPACE:]]+mon$)%"
}


# Для всех остальных файлов БД/алиасов: разрешаем регистрацию 
# выполняемых SQL-выражений любой длительности.
# Важно: специальные требования для security3, top_secret и 
# heavy_production, размещённые в database-секциях выше этой строки, 
# остаются в силе. Эта секция определяет требования для всех 
# ДРУГИХ файлов баз и алиасов:
database =
{
    enabled = true
    log_initfini = false
    log_errors = false

    time_threshold = 0
    log_statement_finish = true
}
]]>
                </programlisting>
            </para>
            <orderedlist>
                <para>Рекомендации:</para>
                <listitem>
                    <para>Всегда размещайте секции с шаблонами <quote>большей конкретики</quote>
                        выше секций, где указаны <quote>общие шаблоны</quote>. Если по некоторой
                        базе нужно заблокировать показ чего-либо в трассировке, добавьте секцию с
                        шаблоном, которому отвечают имя и алиас этой базы, в начало файла.</para>
                </listitem>
                <listitem>
                    <para>Подключения к базе как к файлу с точки зрения трассировки НЕ идентичны
                        подключениям к этой же базе по её алиасу. Поэтому, если вам нужна
                        регистрация всех видов подключений (по имени файла БД и по алиасу),
                        указывайте в database-секции всегда ДВА шаблона. Первым должен быть указан
                        шаблон с именем файла, затем должен следовать разделитель (символ
                        вертикальной черты, без кавычек) и после него надо указать шаблон со всеми
                        возможными алиасами, по которым к данной базе могут выполняться подключения.
                        Если шаблон состоит из нескольких возможных фраз, объединяйте их в круглые
                        скобки:</para>
                    <programlisting>
( %[\\/](heavy_production).fdb | (heavy_prod_alias|alias_for_heavy_prod|prod_alias_heavy) )
                        </programlisting>
                </listitem>
                <listitem>
                    <para>Для предварительной проверки того, будет ли работать шаблон, создайте
                        подключение к базе и выполните выражение:</para>
                    <programlisting>
<![CDATA[
SQL> set list on;
SQL> select 1 from rdb$database where '<expr>' SIMILAR TO '<pattern>';
]]>                                
                            </programlisting>

                    <para>Например, чтобы проверить, будет ли отслеживаться любой допустимый запрос
                        к таблицам мониторинга при использовании шаблона:</para>
                    <programlisting>
<![CDATA[  
include_filter = "%((from|join)[[:WHITESPACE:]]+mon$)%"
]]>
                        </programlisting>
                    <para>— можно сделать следующую проверку:</para>
                    <programlisting>
<![CDATA[  
SQL> select 1 from rdb$database where '
CON> select
CON> mon$server_pid
CON> from
CON>    mon$attachments
CON> where mon$attachments_id = current_connection
CON> '
CON> similar to
CON> '%((from|join)[[:WHITESPACE:]]+mon$)%';
]]>
                        </programlisting>
                    <screen>
    CONSTANT
============
           1                                
                            </screen>
                </listitem>
                <listitem>
                    <para>Шаблоны для include/exclude фильтров лучше всегда указывать в двойных
                        кавычках, даже если они примитивные (select|insert|delete). Шаблоны для имен
                        файлов БД/алиасов указываются без двойных кавычек</para>
                </listitem>
            </orderedlist>
        </section>
        <section>
            <title>Виды отслеживаемых событий</title>

            <orderedlist>
                <para>Трассировка позволяет:</para>
                <listitem>
                    <para>Отследить события, относящиеся к работе приложений c базой данных
                        (старт/завершение транзакций, исполняемых SQL-выражений и др.);</para>
                </listitem>
                <listitem>
                    <para>Установить дополнительные параметры для событий, относящихся к БД
                        (минимальное время длительности, include/exclude-фильтры и др.);</para>
                </listitem>
                <listitem>
                    <para>Установить параметры для работы собственно трассировки (имя лога для
                        системного аудита, размер для переименования лога, и др.);</para>
                </listitem>
                <listitem>
                    <para>Отследить события, относящиеся к сервисам Firebird (администрирование
                        пользователей, управление сессиями трассировки, резервного копирования и
                        прочее).</para>
                </listitem>
            </orderedlist>
            <para>В списке параметров, которые приводятся ниже, все значения считаются логического
                типа (true | false), если не оговорено другое. </para>
            <section>
                <title>Основные параметры для событий, относящихся к работе c базой данных</title>

                <orderedlist numeration="arabic">
                    <listitem>
                        <para>Подключение к базе данных. Регулируется параметром конфигурации
                                <parameter>log_connections</parameter>.</para>
                    </listitem>
                    <listitem>
                        <para>Старт транзакции, завершение транзакции (фиксация или отмена).
                            Параметр: <parameter>log_transactions</parameter>.</para>
                    </listitem>
                    <listitem>
                        <orderedlist numeration="arabic" inheritnum="inherit">
                            <para>Выполнение SQL-запросов:</para>
                            <listitem>
                                <para>Подготока запроса к выполнению. Параметр:
                                        <parameter>log_statement_prepare</parameter>.</para>
                            </listitem>
                            <listitem>
                                <para>Старт запроса (запуск его на выполнение). Параметр:
                                        <parameter>log_statement_start</parameter>.</para>
                            </listitem>
                            <listitem>
                                <para>Окончание выполнения выражения. Для выборок — переход за
                                    последнюю запись, для DML — завершение выполнения. Параметр:
                                        <parameter>log_statement_finish</parameter>.</para>
                            </listitem>
                            <listitem>
                                <para>Высвобождение ресурсов, занимавшихся курсором, выполнявшим
                                    запрос. Параметр:
                                    <parameter>log_statement_free</parameter>.</para>
                            </listitem>
                        </orderedlist>
                    </listitem>
                    <listitem>
                        <orderedlist numeration="arabic" inheritnum="inherit">
                            <para>Выполнение процедурных модулей:</para>
                            <listitem>
                                <para>Старт выполнения хранимой процедуры (созданной как отдельная
                                    или в составе пакета). Параметр:
                                        <parameter>log_procedure_start</parameter>.</para>
                            </listitem>
                            <listitem>
                                <para>Окончание выполнения хранимой процедуры. Параметр:
                                        <parameter>log_procedure_finish</parameter>.</para>
                            </listitem>
                            <listitem>
                                <para>Старт выполнения PSQL-функции (созданной как отдельная или в
                                    составе пакета). Параметр:
                                        <parameter>log_function_start</parameter>.</para>
                            </listitem>
                            <listitem>
                                <para>Окончание выполнения PSQL-функции. Параметр:
                                        <parameter>log_function_finish</parameter>.</para>
                            </listitem>
                            <listitem>
                                <para>Старт выполнения триггера (любого уровня: для каждой записи
                                    или ан события уровня БД). Параметр:
                                        <parameter>log_trigger_start</parameter>.</para>
                            </listitem>
                            <listitem>
                                <para>Окончание выполнения триггера. Параметр:
                                        <parameter>log_trigger_finish</parameter>.</para>
                            </listitem>
                        </orderedlist>
                    </listitem>
                    <listitem>
                        <orderedlist numeration="arabic" inheritnum="inherit">
                            <para>Предупреждения и ошибки, происходящие при компиляции или на этапе
                                выполнения выражений</para>
                            <listitem>
                                <para>Предупреждения. Параметр:
                                    <parameter>log_warnings</parameter>.</para>
                                <para>Пример предупреждения, который часто появляется при работе с
                                    базами 1-го диалекта:
                                    <screen>
SQL warning code = 301 / DATE data type is now called TIMESTAMP                      
                                                </screen>
                                </para>
                            </listitem>
                            <listitem>
                                <para>Регистрация ошибок (разрешение на это). Параметр:
                                        <parameter>log_errors</parameter>.</para>
                            </listitem>
                        </orderedlist>
                    </listitem>
                    <listitem>
                        <para>Изменение контекстных переменных. Регистрируются все обращения к
                            функции RDB$SET_CONTEXT(). Параметр:
                            <parameter>log_context</parameter>.</para>
                    </listitem>
                    <listitem>
                        <para>Компиляция в BLR-код и выполнение BLR-кода (BLR — Binary Language
                            Representation — двоичное представление PSQL-инструкций). Для краткого
                            информирования о фактах успешной компиляции кода (COMPILE_BLR), а также
                            о выполнении команд ISQL, обращающихся к словарю базы (EXECUTE_BLR; в
                            основном, это SHOW-команды), служит параметр
                                <parameter>log_blr_requests</parameter>.</para>
                        <para>Для развернутого показа того, какой именно BLR-код выполняется,
                            применяется параметр <parameter>print_blr</parameter>. Указание
                                <code>print_blr = true</code> требует, чтобы также был указан
                                <code>log_blr_requests = true</code> (иначе ничего регистрироваться
                            не будет).</para>
                    </listitem>
                </orderedlist>

            </section>
            <section>
                <title>Дополнительные параметры для событий, относящихся к работе с базой
                    данных</title>

                <orderedlist numeration="arabic">
                    <listitem>
                        <para>Минимальная длительность выполнения SQL-выражения, процедуры или
                            функции, необходимое для того, чтобы их завершение отразилось в логе
                            трейса.</para>
                        <para>Параметр: <parameter>time_threshold</parameter>, числовой. Измерение:
                            миллисекунды. </para>
                        <para>Значение по умолчанию: 100.</para>
                        <tip>
                            <title>РЕКОМЕНДАЦИЯ</title>

                            <para>Никогда не удаляйте строку с этим параметром. Может оказаться так,
                                что вы не увидите в трассировки никакой активности, но на самом деле
                                она там будет. Это произойдёт в случае, когда все выполняемые
                                выражения и процедуры длятся менее 100 мс — умалчиваемого лимита для
                                параметра <parameter>time_threshold</parameter>. Удаление этой
                                строки затруднит поиск причины, по которой в трассировки нет показа
                                активности приложений.</para>
                        </tip>
                    </listitem>
                    <listitem>
                        <para>Фильтрация выполняемых SQL-выражений через include/exclude списки
                            шаблонов.</para>
                        <para>Списки работают по принципу: <itemizedlist>
                                <listitem>
                                    <para>регистрировать только тех выражения, которые содержат хотя
                                        бы один из шаблонов из include-списка;</para>
                                </listitem>
                                <listitem>
                                    <para>запретить регистрацию тех выражений, которые содержат хотя
                                        бы один из шаблонов из exclude-списка.</para>
                                </listitem>
                            </itemizedlist></para>
                        <para>Параметры: <parameter>include_filter</parameter> и
                                <parameter>exclude_filter</parameter>. Значения: см. примеры далее в
                            тексте.</para>
                        <para>Эти параметры работают только при условии, что хотя бы один из
                            следующих параметров равен true:
                                <parameter>log_statement_prepare</parameter>,
                                <parameter>log_statement_start</parameter>,
                                <parameter>log_statement_finish</parameter>,
                                <parameter>log_statement_free</parameter>.</para>
                    </listitem>
                    <listitem>
                        <para>Фильтрация ошибок через include/exclude-списки кодов ошибок или их
                            мнемонических обозначений.</para>
                        <para>Списки работают по принципу: <itemizedlist>
                                <listitem>
                                    <para>регистрировать только тех ошибки, которые принадлежат
                                        include-списку;</para>
                                </listitem>
                                <listitem>
                                    <para>запретить регистрацию тех ошибок, которые принадлежат
                                        exclude-списку.</para>
                                </listitem>
                            </itemizedlist></para>
                        <para>Параметры: <parameter>include_gds_codes</parameter> и
                                <parameter>exclude_gds_codes</parameter>. Значения: см. примеры
                            далее в тексте. Эти параметры работают только при условии, что
                                <code>log_errors = true</code>.</para>
                    </listitem>
                    <listitem>
                        <para>Печать плана выполнения SQL-запроса: <orderedlist numeration="arabic"
                                inheritnum="inherit">
                                <listitem>
                                    <para>В кратком ("традиционном") виде:
                                        <programlisting>
PLAN (RDB$DATABASE NATURAL)                                                    
                                                </programlisting>
                                    </para>
                                    <para>Параметр: <parameter>print_plan</parameter>.</para>
                                </listitem>
                                <listitem>
                                    <para>В развернутом виде (доступно начиная с Firebird 3.0):
                                        <programlisting>
Select Expression
    -> Table "RDB$DATABASE" Full Scan                                                  
                                                </programlisting>
                                    </para>
                                    <para>Параметр: <parameter>explain_plan</parameter>.</para>
                                    <para>Работает только при условии, что <code>print_plan =
                                            true</code>. При указании обоих параметров в true будет
                                        выводиться только развернутый план.</para>
                                </listitem>
                            </orderedlist></para>
                        <para>Эти параметры работают только при условии, что хотя бы один из
                            следующих параметров равен true:
                                <parameter>log_statement_prepare</parameter>,
                                <parameter>log_statement_start</parameter>,
                                <parameter>log_statement_finish</parameter>,
                                <parameter>log_statement_free</parameter>.</para>
                    </listitem>
                    <listitem>
                        <para>Печать статистики выполнения SQL-запросов и PSQL-модулей.</para>
                        <para>При заказе этой статистики в логе будут выведены длительность
                            выполнения и значения счетчиков fetches, reads, writes, marks. Для
                            SQL-выражений будут показаны сводные данные по операциям, которые
                            выполнялись над таблицами: общее количество чтений, модификаций записей
                            и др.</para>
                        <para>Параметр: <parameter>print_perf</parameter>.</para>
                        <para>Статистика выводится только для того вида события, по которому задан
                            параметр регистрации, то есть:<itemizedlist>
                                <listitem>
                                    <para>если задан <parameter>log_statement_finish</parameter>, то
                                        будет выводиться статистика по выполнявшимся
                                        SQL-выражениям;</para>
                                </listitem>
                                <listitem>
                                    <para>если задан <parameter>log_procedure_finish</parameter>, то
                                        будет выводиться статистика по выполнявшимся хранимым
                                        процедурам и так далее.</para>
                                </listitem>
                            </itemizedlist></para>
                    </listitem>
                    <listitem>
                        <para>Ограничение длины текста регистрируемых событий: <orderedlist
                                numeration="arabic" inheritnum="inherit">
                                <listitem>
                                    <para>Максимальная длина выполняемого SQL-выражения. Параметр:
                                            <parameter>max_sql_length</parameter>, значение по
                                        умолчанию: 300.</para>
                                </listitem>
                                <listitem>
                                    <para>Максимальная длина отдельного аргумента, который
                                        передается SQL-выражению. Параметр:
                                            <parameter>max_arg_length</parameter>, значение по
                                        умолчанию: 80.</para>
                                </listitem>
                                <listitem>
                                    <para>Максимальное количество аргументов, которые будут показаны
                                        в трейсе (ниже последнего будет выведено "..."). Параметр:
                                            <parameter>max_arg_count</parameter>, значение по
                                        умолчанию: 10.</para>
                                </listitem>
                                <listitem>
                                    <para>Максимальная длина выводимого BLR-запроса. Параметр:
                                            <parameter>max_blr_length</parameter>, значение по
                                        умолчанию: 500.</para>
                                </listitem>
                                <listitem>
                                    <para>Максимальная длина выводимой dyn-request
                                        инструкции.</para>
                                    <para>Под термином 'DYN' понимается язык, ранее (в эпоху
                                        InterBase) называвшийся GDEF. От него отказались еще в IB
                                        4.0, но затем он был снова возвращен в открытой версии
                                        Interbase 6.0 (уже под именем DYN). И хотя этот язык
                                        манипулирования метаданными не разрешен к использованию в
                                        Firebird 3.0, возможность отслеживания инструкций на нем до
                                        сих пор оставлена (только в системном аудите).</para>
                                    <para>Параметр: <parameter>max_dyn_length</parameter>, значение
                                        по умолчанию: 500.</para>
                                </listitem>
                            </orderedlist></para>
                    </listitem>
                    <listitem>
                        <para>Ограничение показа активности, выполняемой только одним
                            подключением.</para>
                        <para>Параметр: <parameter>connection_id</parameter>, числовой. Значение по
                            умолчанию: 0 — означает регистрацию активности от всех
                            подключений.</para>
                    </listitem>
                </orderedlist>

            </section>
            <section>
                <title>Дополнительные параметры для системного аудита</title>

                <orderedlist>
                    <listitem>
                        <para>Системный аудит, запускаемый автоматически при старте Firebird, должен
                            "знать" имя конфигурационного файла, который необходимо прочитать перед
                            началом работы.</para>
                        <para>Имя этого файла назначается в конфигурационном файле СЕРВЕРА,
                                <filename>firebird.conf</filename>, параметром
                                <parameter>AuditTraceConfigFile</parameter>. </para>
                        <important>
                            <para>Отсутствие значения у этого параметра (или помещение его под
                                комментарий) означает выключение системного аудита. Это произойдет
                                при рестарте Firebird.</para>
                        </important>
                    </listitem>
                    <listitem>
                        <para>В файле конфигурации трассировки существует параметр
                                <parameter>log_filename</parameter>, значение которого должно быть
                            именем файла, в который будет проводиться запись лога аудита. Это имя
                            будет далее использоваться в механизме переименований логов при их
                            заполнении до лимита, указанного параметром
                                <parameter>max_log_size</parameter>. См. следующий пункт.</para>
                    </listitem>
                    <listitem>
                        <para>В файле конфигурации трассировки существует параметр
                                <parameter>max_log_size</parameter>, значение которого измеряется в
                            мегабайтах. Он служит для цели автоматического переименования логов с
                            целью недопущения бесконечного роста только лишь одного файла
                                (<quote>текущего</quote> журнала).</para>
                        <para>Его значение — это максимальный размер лога системного аудита, по
                            достижении которого запись в текущий (заполненный) лог останавливается,
                            лог переименовывается, а затем запись новых сообщений продолжается в
                            НОВЫЙ файл с именем, указанный в параметре
                                <parameter>AuditTraceConfigFile</parameter>.</para>
                        <para>По умолчанию значение равно 0, что подразумевает отсутствие
                            переименований файлов и запись всего аудита только в один файл.</para>
                        <important>
                            <title>Важно</title>

                            <itemizedlist>
                                <listitem>
                                    <para>этот параметр относится только к системному аудиту.
                                        Пользовательская трассировка всегда пишется только в тот
                                        файл, который был указан в командной строке запуска.</para>
                                </listitem>
                                <listitem>
                                    <para>круговой ротации логов аудита (т.е. использования их по
                                        "револьверному принципу") в готовом виде нет. Это является
                                        задачей администратора сервера Firebird.</para>
                                </listitem>
                            </itemizedlist>

                        </important>
                    </listitem>
                </orderedlist>
            </section>
            <section>
                <title>События, относящиеся к сервисам Firebird</title>

                <para>Многие действия можно выполнять, вызывая функции из набора, называемого
                    сервисами Firebird. Например управление сессиями трассировки, резервное
                    копирование, сбор статистики и прочее.</para>
                <para>Эти функции доступны как через API, так и через вызов утилиты командной строки
                    fbsvcmgr.</para>
                <para>Трассировка позволяет отследить активность вызовов функций, относящихся к
                    сервисам Firebird. Кроме того, делать это можно с указанием include/exclude
                    фильтров, перечисляя только те функции, которые интересуют.</para>

                <orderedlist>
                    <para>Допускается отслеживание следующих сервисных функций:</para>
                    <listitem>
                        <orderedlist spacing="compact" numeration="arabic" inheritnum="inherit">
                            <para>Работа с базами данных:</para>
                            <listitem>
                                <para>Backup Database</para>
                            </listitem>
                            <listitem>
                                <para>Restore Database</para>
                            </listitem>
                            <listitem>
                                <para>Repair Database</para>
                            </listitem>
                            <listitem>
                                <para>Incremental Backup Database</para>
                            </listitem>
                            <listitem>
                                <para>Incremental Restore Database</para>
                            </listitem>
                        </orderedlist>
                    </listitem>
                    <listitem>
                        <orderedlist spacing="compact" numeration="arabic" inheritnum="inherit">
                            <para>Администрирование пользователей</para>
                            <listitem>
                                <para>Add User</para>
                            </listitem>
                            <listitem>
                                <para>Delete User</para>
                            </listitem>
                            <listitem>
                                <para>Modify User</para>
                            </listitem>
                            <listitem>
                                <para>Display User</para>
                            </listitem>
                            <listitem>
                                <para>Set Domain Admins Mapping to RDB$ADMIN</para>
                            </listitem>
                            <listitem>
                                <para>Drop Domain Admins Mapping to RDB$ADMIN</para>
                            </listitem>
                        </orderedlist>
                    </listitem>
                    <listitem>
                        <orderedlist spacing="compact" numeration="arabic" inheritnum="inherit">
                            <para>Показ свойств и статистики по БД. Получение содержимого
                                    <filename>firebird.log</filename></para>
                            <listitem>
                                <para>Database Properties</para>
                            </listitem>
                            <listitem>
                                <para>Database Stats</para>
                            </listitem>
                            <listitem>
                                <para>Get Log File</para>
                            </listitem>
                        </orderedlist>
                    </listitem>
                    <listitem>
                        <orderedlist spacing="compact" numeration="arabic" inheritnum="inherit">
                            <para>Управление сессиями пользовательского трассировки: </para>
                            <listitem>
                                <para>Start Trace Session</para>
                            </listitem>
                            <listitem>
                                <para>Stop Trace Session</para>
                            </listitem>
                            <listitem>
                                <para>Suspend Trace Session</para>
                            </listitem>
                            <listitem>
                                <para>Resume Trace Session</para>
                            </listitem>
                            <listitem>
                                <para>List Trace Sessions</para>
                            </listitem>
                        </orderedlist>
                    </listitem>
                </orderedlist>

                <para>Секция в конфигурации трассировки, объявляющая слежение за вызовами сервисов
                    Firebird, может содержать следующие параметры:</para>
                <programlisting>
<![CDATA[
services 
{
    # Разрешается ли применение этой секции
    enabled = false

    # Имя файла, используемого как журнал операций при работе системного аудита:
    #log_filename = name

    # Максимальный размер журнала (в мегабайтах), используемый системным аудитом 
    # как порог для начала переименования лога и перевода дальнейшей записи 
    # в новый (пустой) файл, задаваемый параметром <log_filename>:
    #max_log_size = 0

    # Services filters.
    #
    # Only services whose names fall under given regular expression are 
    # reported in the log.

    # Фильтрация имен сервисов, которые могут попадать в лог (НЕ чувствиительна 
    # к регистру символов):
    #
    # 1. Включающая фильтрация (сохранять только те сервисы, которые присутствуют 
    #    в списке шаблонов include_filter).
    #    Внимание: при включенном параметре log_services в лог будут попадать 
    #    события подключения и отключения от сервиса, даже если имя функции не 
    #    отвечает шаблону include_filter. Пример разершения регистрации только 
    #    двух вызовов: "%((backup database)|(restore database))%"
    #include_filter

    # 2. Искючающая фильтрация (Не регистрировать вызовы тех сервисов, которые 
    # присутствуют в списке шаблонов exclude_filter):
    #exclude_filter 

    # Регистрировать ли события подключения к сервисной функции, её старта и 
    # отключения от сервиса
    log_services = false

    # Регистрировать ли запросы, идущие от сервиса
    log_service_query = true

    # Регистрировать ли ошибки, происходящие при обращении к сервисной 
    # функции Firebird
    log_errors = true

    # Регистрировать ли предупреждения
    #log_warnings = false

    # Filters for errors and warnings GDS codes.
    # Comma separated list of GDS codes values and\or names.
    # For example: deadlock, req_sync, 335544321

    # Include filter. If empty, trace all errors\warnings events.
    # Else trace event if any code from list is found in status-vector.

    # Фильтрация ошибок, возникающих при вызове сервисных функций:
    #    Включающая фильтрация: регистрировать только те ошибки, чьи числовые 
    #    коды или мнемонические имена принадлежат
    #    к указанному списку:
    #include_gds_codes

    #    Исключающая фильтрация: НЕ регистрировать те ошибки, чьи числовые 
    #    коды или мнемонические имена принадлежат
    #    к указанному списку:
    #exclude_gds_codes

}
]]>                    
                </programlisting>

            </section>
            <section>
                <title>Контроль состояния пользовательской трассировки</title>

                <formalpara>
                    <title>Расположение:</title>
                    <para><filename>firebird.conf</filename>.</para>
                </formalpara>
                <formalpara>
                    <title>Параметр:</title>
                    <para><parameter>MaxUserTraceLogSize</parameter>.</para>
                </formalpara>
                <formalpara>
                    <title>Значение по умолчанию:</title>
                    <para>10</para>
                </formalpara>
                <formalpara>
                    <title>Единица измерения:</title>
                    <para>Мб, мегабайт.</para>
                </formalpara>
                <para>Задает максимальный суммарный размер временных файлов, создаваемых сессией
                    пользовательской трассировки Services API.</para>
                <para>Этот параметр ограничивает объём информации трассировки, которая может
                    храниться на сервере до того, как она будет прочитана клиентом.</para>
                <para>Пользовательский трассировка пишет свои данные асинхронно, не дожидаясь ответа
                    от клиента о готовности приему очередного сообщения. Для реализации этого при
                    работе трейса создаются временные файлы для хранения текста, который еще не был
                    прочитан. Клиент может читать данные медленнее, чем их генерирует сервер,
                    поэтому необходимо контролировать их общий размер. Если этот общий размер
                    превысит некоторый порог, пользовательская сессия трассировка будет
                    приостановлена с выводом сообщения:
                    <screen>
--- Session &lt;NN&gt; is suspended as its log is full ---            
                    </screen>
                </para>
                <para>После того, как клиентское приложение закончит читать последний из файлов,
                    трассировка автоматически возобновится.</para>

                <important>
                    <para>Активность в базе данных происходившая в период паузы трассировки ввиду
                        "медлительности" клиента, НЕ будет зафиксирована.</para>
                    <para>Это значит, что на практике параметр
                            <parameter>MaxUserTraceLogSize</parameter> должен иметь значение,
                        исключающее приостановку трассировки. Для наблюдения за размером временных
                        файлов трассировки нужно сначала получить информацию о том, где содержится
                        лок-таблица. Поскольку эти файлы всегда создаются в том же каталоге:</para>
                    <screen>
# /opt/firebird/bin/fbsvcmgr localhost:service_mgr user sysdba 
password masterkey info_get_env_lock

Path to lock files: /tmp/firebird/
                    </screen>

                    <para>Затем (в Linux) можно воспользоваться командой watch:</para>
                    <screen>
watch -n 1 "ls -l /tmp/firebird/fb*_trace* | awk '{print \$9,\$5}' ; 
ls -l /tmp/firebird/fb*_trace* | wc -l"                            
                        </screen>

                    <para>Пример её вывода:</para>
                    <screen>
Every 1.0s: ls -l /tmp/firebird/fb*_trace* | awk '{print $9,$5}' ; 
ls -l /tmp/firebird/fb*_trace* | wc -l  Thu Dec 14 10:51:25 2017    

/tmp/firebird/fb12_trace 4192
/tmp/firebird/fb_trace.{6F356FF8-5D63-4AC5-4E88-4959A27A6ED5} 88
/tmp/firebird/fb_trace.{6F356FF8-5D63-4AC5-4E88-4959A27A6ED5}.0000151 1048576
/tmp/firebird/fb_trace.{6F356FF8-5D63-4AC5-4E88-4959A27A6ED5}.0000152 1048576
/tmp/firebird/fb_trace.{6F356FF8-5D63-4AC5-4E88-4959A27A6ED5}.0000153 1048576
/tmp/firebird/fb_trace.{6F356FF8-5D63-4AC5-4E88-4959A27A6ED5}.0000154 461276
/tmp/firebird/fb_trace_iPi4m3 1443
7
                    </screen>

                    <para>Предельный размер каждого файла равен 1 Мб. Если количество этих файлов
                        часто приближается к значению параметра
                            <parameter>MaxUserTraceLogSize</parameter>, следует увеличить
                        его.</para>
                </important>
                <para>Дополнительно про параметр <parameter>MaxUserTraceLogSize</parameter> можно
                    прочитать <link
                        xlink:href="https://www.firebirdsql.org/file/documentation/release_notes/html/ru/rlsnotes25.html#rnfb25-fbconf-maxtrace"
                        >здесь</link>.</para>
            </section>
        </section>
        <section>
            <title>Примеры полезных конфигураций</title>
            <informalexample>
                <para>Запретить отслеживание базы учетных записей пользователей, разрешить
                    наблюдение за возникающими ошибками в базе 'foo', которая может иметь расширения
                        <filename>.fdb</filename> или <filename>.gdb</filename> и находиться в любом
                    каталоге:</para>
                <programlisting>
database = (%[\\/](security3).fdb|(security.db))
{
    enabled = false
}

database = ( %[\\/](foo)(.fdb|.gdb) )
{
    enabled = true
    log_initfini = false
    log_errors = true
    time_threshold = 0
}                    
                </programlisting>

                <tip>
                    <para>Для проверки того, будет ли работать шаблон в секции database, можно
                        ввести на выполнение следующее выражение с SIMILAR TO
                        <programlisting language="sql">
select 1 from rdb$database 
where _utf8 'c:\temp\data\fOO.Gdb' collate unicode_ci similar 
      to _utf8 '%[\\/](foo)(.fdb|.gdb)' collate unicode_ci;                        
                    </programlisting>
                    </para>
                    <para>Результат его выполнения будет не пустым, следовательно шаблон —
                        корректный.</para>
                </tip>
            </informalexample>
            <informalexample>
                <para>Разрешить отслеживание активности во всех базах, расположенных в каталоге
                        <filename>c:\data\fb3x\</filename>, и его подкаталогах. Отслеживать только
                    SQL-выражения, длительность выполнения которых 1000 мс и выше.</para>
                <programlisting>
database = ( 'c:\data\fb3x([\\][^\]+)+.fdb' )
{
    enabled = true
    log_initfini = false
    time_threshold = 1000
    log_statements = true
}                        
                    </programlisting>

            </informalexample>
            <informalexample>
                <para>Отслеживать только запросы к таблицам мониторинга (во всех базах и
                    алиасах).</para>
                <programlisting>
database =
{
    enabled = true
    log_initfini = false
    log_errors = false
    time_threshold = 0
    log_statement_finish = true
    include_filter = "%((from|join)[[:WHITESPACE:]]+mon$)%"
}                        
                    </programlisting>

            </informalexample>
            <informalexample>
                <para>Накопление сведений по ошибкам отдельных видов, возникавшим при работе
                    приложений при подключении их к базе 'foo.fdb' или к двум возможным её алиасам
                    'bar' и 'gee'.</para>
                <programlisting>
database = ( %[\\/](foo).fdb | (bar|gee) )
{
    enabled = true
    log_initfini = false
    log_errors = true
    include_gds_code
    time_threshold = 0

    # Разрешаем регистрацию:
    # всех видов переполнения (арифметических, строковых)
    # нарушения уникального ключа
    # нарушения первичного ключа

    # Запись через перечисление мнемоник исключений:
    include_gds_codes = arith_except,unique_key_violation,no_dup

    # То же самое, через "комбинированную" запись мнемоник и числовых кодов ошибок:
    #include_gds_codes = arith_except,unique_key_violation,335544349

    # Запрещаем регистрацию:
    # исключения, вызванного прерыванием операции (клиентом или администратором БД)
    # любого пользовательского исключения,
    # вызванного попыткой курсора прочесть запись после достижения 
    # конца выборки (фактически ошибкой не является)

    # Запись через перечисление мнемоник исключений:
    exclude_gds_codes = cancelled,user_exc,req_sync

    # То же самое, через запись числовых кодов: 
    # exclude_gds_codes = 335544794,335544517,335544364
}                        
                    </programlisting>

            </informalexample>
            <section>
                <title>Отслеживание вызова сервисов</title>
                <para>Следующий конфигурационный файл позволит вам отслеживать запуски резервного
                    копирования.</para>
                <programlisting>
services 
{
    enabled = true
    log_initfini = false
    include_filter = "%(backup database)%"
    log_services = true
}                    
                </programlisting>

                <para>Например, при вводе следующей команды:</para>
                <programlisting>
C:\FB\30SS\fbsvcmgr.exe localhost:service_mgr user sysdba password masterkey 
action_backup dbname c:\temp\test.fdb bkp_file c:\temp\test.fbk                        
                    </programlisting>

                <para>Журнал трассировки будет содержать следующее:</para>
                <screen>
2017-12-15T14:23:55.1150 (3972:0000000002B30040) ATTACH_SERVICE
        service_mgr, (Service 00000000022EB140, SYSDBA, TCPv6:::1/57162, 
        C:\FB\30SS\fbsvcmgr.exe:7152)

2017-12-15T14:23:55.1150 (3972:0000000002B30040) START_SERVICE
        service_mgr, (Service 00000000022EB140, SYSDBA, TCPv6:::1/57162, 
        C:\FB\30SS\fbsvcmgr.exe:7152)
        "Backup Database"
        C:\FBTESTING\qa\fbt-repo\tmp\e30.fdb 
        C:\FBTESTING\qa\fbt-repo\tmp\e30-tmp2.fbk

2017-12-15T14:23:55.8920 (3972:0000000002B30040) DETACH_SERVICE
        service_mgr, (Service 00000000022EB140, SYSDBA, TCPv6:::1/57162, 
        C:\FB\30SS\fbsvcmgr.exe:7152)                    
                </screen>

                <note>
                    <para>Некоторые строки в выводе трассировки перенесены поскольку они не
                        помещаются на экран.</para>
                </note>
            </section>
        </section>
        <section>
            <title>Структура заголовка выводимого блока информации</title>

            <para>Под заголовком блока в следующем примере понимается текст, расположенный на
                строках 1...4:</para>
            <programlisting linenumbering="numbered">
2017-12-15T21:17:18.3590 (2424:01EF2620) EXECUTE_STATEMENT_FINISH
    e30 (ATT_63, SYSDBA:NONE, NONE, TCPv4:192.168.1.57/1449)
    C:\MIX\firebird\fb30\isql.exe:3924
        (TRA_67, READ_COMMITTED | NO_REC_VERSION | WAIT | READ_WRITE)

Statement 20:
-------------------------------------------------------------------------------
SELECT CURRENT_USER, CURRENT_ROLE FROM RDB$DATABASE
...                
            </programlisting>

            <para>Этот текст является одинаковым для любого события, зарегистрированного для
                отслеживаемого подключения.</para>

            <para>В строке 1 всегда указывается штамп даты и времени, к которому относится
                зарегистрированное событие. Затем в круглых скобках указывается служебная информация
                трассировки, после чего — вид события. Если к событию применимо понятие
                "успех"/"неудача", то при успехе пишется только само событие, а при неудаче слева от
                него пишется слово 'FAILED '.</para>
            <para>В строке 2 указывается либо полное имя файла базы, либо алиас — то, что было
                указано клиентом при подключении. Далее с круглых скобках указаны: ID подключения
                ("ATT_nnnnn"), имя пользователя и его роль (через двоеточие), набор символов
                подключения (client charset), затем протокол и, если это TCPv4 или TCPv6, то далее
                через двоеточие указаны адрес и порт. Для локального протокола будет указано
                &lt;internal&gt;.</para>
            <para>В строке 3 указано полное имя клиентского приложения, выполнившего подключение, и
                порт. Для подключений, выполненных с помощью драйвера, который не требует наличия на
                клиентской машине библиотеки fbclient, может отсутствовать строка с именем
                приложения (<application>isql.exe</application>). На сегодня таким является
                JDBC-драйвер JayBird. Кроме того, строка с информацией о приложении может
                отсутствовать, если это приложение использует очень старую версию библиотеки
                fbclient (до версии 2.1.0).</para>
            <para>В строке 4 указывается ID транзакции ("TRA_nnnnn"), уровень изолированности
                транзакции, режим WAIT/NO_WAIT и режим чтения/записи.</para>
            <note>
                <para>При отсутствии информации о клиентском процессе строка номер 4 становится
                    строкой номер 3 (то есть пропуска в виде пустой строки не возникнет).</para>
            </note>
        </section>

        <section>
            <title>Кодировка non-ascii информации</title>

            <para>Текст, в котором есть non-ascii строки, отображается в трассировки всегда в
                кодировке UTF8, если сборка Firebird датирована 19.07.2017 (3.0.3.32758) или более
                поздняя. Для более ранних сборок существовала особенность: строковые параметры к
                вызываемым хранимым процедурам передавались в кодировке того подключения, которое
                выполняло соответствующий вызов. Лог трассировки для таких сборок, при просмотре его
                на машине с локалью UTF8, будет содержать нечитабельные строковые параметры к
                процедурам, если эти параметры содержат кириллицу и клиентские приложения объявляли
                кодировку подключения WIN1251.</para>

            <para>Чтобы выполнить перекодировку, воспользуйтесь инструментами операционной системы
                или сторонних производителей.</para>

            <para>Пример преобразования в POSIX (для случая, когда вызывавший процесс указывал при
                подключении к базе кодировку WIN-1251, а фрагмент трассировки сохранен в файле
                    <filename>/tmp/non-ascii-sample.txt</filename>):</para>
            <programlisting>
cat /tmp/non-ascii-sample.txt | iconv -f WINDOWS-1251 -t UTF-8                    
                </programlisting>

        </section>
    </section>

    <section>
        <title>Использование таблиц мониторинга MON$</title>
        <para>Запросы к таблицам мониторинга могут оказать большую помощь при обследовании работы БД
            под нагрузкой. В частности, можно быстро получить информацию о транзакции, являющейся
            OAT (и с какого времени она запущена), о запросах, которые выполняются выбранной
            транзакцией, о суммарном количестве операций чтения и записи, о статистике операций по
            конкретным таблицам, о накоплении версий записей, и многое другое.</para>
        <para>Все эти действия можно быстро выполнять и анализировать такими средствами, как
                <application>Mon$logger</application> от компании IBSurgeon.</para>
        <para>Информация о предназначении таблиц мониторинга и их полях (метаданных) изложена
                <quote>Руководстве по SQL-языку СУБД Firebird 3.0</quote> (приложение
                <quote>Е</quote>). </para>
        <para>Следует постоянно иметь в виду, что частый сбор информации с помощью таблиц
            мониторинга в сильно нагруженной среде может негативно отразиться на производительности
            системы, если этот сбор запрашивается SYSDBA или тем пользователем, под чьей учетной
            записью в данный момент имеется большое количество подключений. </para>
        <para>Причина этого в том, что любой запрос к таблицам мониторинга рассылает сигнал всем
            подключениям с требованием сообщить информацию о своем состоянии (это делает даже такой
            запрос, как <code language="sql">select mon$database_name from from
            mon$database</code>). Более того, это требование о передаче информации остается
            актуальным для подключений даже тогда, когда тот, кто выдал такой запрос, отключился от
            базы данных (или его подключение было удалено администратором).</para>
        <para>Кроме того, пока длится сбор информации мониторинга (а это может происходить в течение
            30-60 секунд на нагруженных системах), к базе данных невозможно установить новое
            подключение: клиентский процесс, создающий подключение к базе, обязан сделать запись в
            те же структуры данных, в которые сейчас пишется информация мониторинга, то есть он
            вынужден будет ждать окончания этой записи.</para>
        <para>В версии Firebird 3.0 есть улучшение: если к таблицам мониторинга обращается обычный
            пользователь (не SYSDBA), то подключения от всех остальных пользователей будут
            игнорировать его запрос (ранее этот запрос не игнорировался, несмотря на то, что такой
            пользователь всё равно не мог видеть чужой активности). Тем не менее, предостережение
            остается актуальным, так как большинство запросов к мониторингу на практике выполняются
            от имени SYSDBA.</para>
        <para>Одним из мест, где НЕ должно быть никаких обращений к таблицам мониторинга без
            дополнительных строгих ограничений, являются триггеры уровня базы данных (database-level
            triggers), потому что они вызываются с наибольшей частотой по сравнению со всеми другими
            объектами БД. Если вам действительно нужно добавить в такой триггер обращение к
            mon$-таблице, обязательно добавьте ограничение на имя пользователя/роли, под которой
            должен выполняться этот код.</para>
        <para>Далее представлены практические примеры использования этих таблиц и несколько
            предупреждений/советов по ним. Почти во всех примерах перед инструкцией обращения к
            таблицам мониторинга явно указан <code>commit;</code>. Это сделано намеренно, чтобы
            акцентировать внимание на том, что мониторинг в Firebird работает в уровне
            изолированности SNAPSHOT. Новые данные видны мониторингу только после старта
            соответствующего запроса в новой транзакции.</para>

        <section>
            <title>Отключение пользователей от базы данных</title>


            <programlisting language="sql">
commit; 
delete from mon$attachments where mon$attachment_id &lt;&gt; current_connection;                    
                </programlisting>
            <para>или просто</para>
            <programlisting language="sql">
commit; 
delete from mon$attachments;                    
                </programlisting>


            <note>
                <para> Можно не опасаться, что будет удалено собственное подключение: этого не
                    происходит, хотя при включенной опции <code>SET COUNT ON</code> (в ISQL)
                    результат может ввести в заблуждение:</para>
                <programlisting language="sql">
set count on;
set list on;
select * from mon$attachments where mon$attachment_id = current_connection;                  
                </programlisting>
                <screen>
MON$ATTACHMENT_ID               15
MON$SERVER_PID                  8384
...

Records affected: 1                        
                    </screen>
                <programlisting language="sql">
delete from mon$attachments where mon$attachment_id = current_connection;                  
                </programlisting>
                <screen>
Records affected: 1                        
                    </screen>

                <para>Вроде бы удалили своё подключение. Проверяем.</para>
                <programlisting language="sql">
commit; 
select * from mon$attachments where mon$attachment_id = current_connection;                  
                </programlisting>
                <screen>
MON$ATTACHMENT_ID               15
MON$SERVER_PID                  8384
...

Records affected: 1                        
                    </screen>

                <para>Также при использовании <code>delete from mon$attachments</code> можно не
                    опасаться удалить системные коннекты (в архитектуре SuperServer): подключения от
                    Cache Writer и Garbage Collect имеют значение <code>mon$system_flag = 1</code>,
                    что предохраняет их от любых воздействий через mon$attachments.</para>
            </note>
            <warning>
                <itemizedlist>
                    <listitem>
                        <para>Возврат управления сеансу, который вызвал отключение всех подключений,
                            происходит до того, как на самом деле эти подключения полностью завершат
                            работу по отмене своих незафиксированных изменений. Отмены не
                            показываются в трассировке, поэтому можно сделать ошибочный вывод о том,
                            что раз управление вернулось в скрипт, выполнивший <code>delete from
                                mon$attachments ...</code>, то далее можно начинать какие-то
                            операции, предполагающие монопольный доступ к БД.</para>
                        <para>Для гарантированно монопольного доступа к базе лучше перевести её в
                            полный offline-режим (<code>gfix -shut full</code>). При выполнении
                            команды <code>gfix -shut full</code> управление точно НЕ возвращается
                            тому, кто её ввёл, до тех пор, пока в базе не завершится вся активность,
                            в том числе и внутренние действия Firebird по отмене изменений.</para>
                    </listitem>
                    <listitem>
                        <para>Сигнал соединению о необходимости прекратить работу может быть принят
                            к исполнению с задержкой, если соединение находится в ожидании данных от
                            удаленного сервера (то есть запустили <code>execute statement on
                                external</code>) и имеются проблемы в сетевой передаче данных от
                            этого сервера. Кроме того, соединение может вообще не принимать в расчет
                            этот сигнал, если занят интенсивными вычислениями при работе с
                            оператором SIMILAR TO (до момента окончания работы этого
                            оператора).</para>
                    </listitem>
                    <listitem>
                        <para>Триггеры для событий базы данных DISCONNECT и ROLLBACK не будут
                            вызваны при отключении через таблицы <code>DELETE FROM
                                MON$ATTACHMENTS</code> (смотри также документацию <quote>Руководство
                                по SQL-языку Firebird</quote>, раздел <quote>Триггеры на событие
                                базы данных</quote>/<quote>предостережения</quote>). Транзакция
                            будет переведена в состояние <quote>Dead</quote>.</para>
                        <para>Причина такого поведения в том, что указание от ДБА удалить соединение
                            — это форсмажор с точки зрения сервера, и этот форсмажор диктует
                            немедленное прекращение всякой активности в данном соединении (в отличие
                            от потери связи с клиентом, что является обычной, не аварийной
                            ситуацией, при которой сервер <quote>без суеты</quote> откатывает
                            текущую работу и закрывает соединение, вызывая все соответствующие
                            триггеры).</para>
                    </listitem>
                    <listitem>
                        <para>Если команда разрыва соединения пришлась на момент времени, когда
                            соединение начало выполнять команду COMMIT (но еще не закончил её, так
                            как транзакция сделала очень много изменений и фиксация НЕ мгновенна),
                            то сначала будет завершён COMMIT, и только после этого произойдёт разрыв
                            соединения.</para>
                    </listitem>
                </itemizedlist>

            </warning>
        </section>
        <section>
            <title>Отключение от БД подключений, которые могут привести к застреванию счетчика
                OAT</title>

            <itemizedlist>
                <para>Соединения, в которых стартовали и до сих пор активны транзакции, отвечающие
                    следующим условиям:</para>
                <listitem>
                    <para>являются пишущими;</para>
                </listitem>
                <listitem>
                    <para>стартовали с уровнем изолированности, отличным от READ COMMITTED
                        RECORD_VERSION;</para>
                </listitem>
                <listitem>
                    <para>имеют возраст свыше некоторого порога (например, 120 минут);</para>
                </listitem>
                <listitem>
                    <para>не меняли ничего в базе данных с момента своего старта.</para>
                </listitem>
            </itemizedlist>
            <para>Такие соединения можно рассматривать в качестве кандидатов на отключение от базы,
                если имеется риск застревания OAT. Можно дополнительно поставить защитный фильтр на
                имена процессов, которые не должны отключаться от базы ни при каких обстоятельствах,
                а также добавить список IP-адресов, подключения от которых также нельзя
                затрагивать.</para>
            <para>Следующий запрос возвращает информацию из mon$attachments, которая отвечает
                указанным критериям. В CTE-частях 'm' и 'p' приведены данные по именам процессов и
                IP-адреса (для примера), которые учитываются в защитной фильтрации.</para>
            <programlisting language="sql">
<![CDATA[
with
m as (
    select 'gfix' as special_process from rdb$database union all
    select 'gstat' from rdb$database union all
    --select 'isql' from rdb$database union all
    select 'fbsvcmgr' from rdb$database
),
p as (
    select '127.0.0.1' as special_address from rdb$database union all
    select '192.168.15.1'  from rdb$database union all
    select '192.168.17.1'  from rdb$database union all
    select '192.168.1.5' from rdb$database
),
u as ( 
    select 120 as max_time_to_live
    from rdb$database
)

select a.*
from mon$attachments a
where 
    a.mon$attachment_id <> current_connection
and exists(
    select 1 
    from mon$transactions t
    join mon$io_stats i on t.mon$stat_id = i.mon$stat_id
    cross join u
    where 
        a.mon$attachment_id = t.mon$attachment_id
        and t.mon$read_only = 0
        and t.mon$isolation_mode <> 2
        and datediff(minute from t.mon$timestamp to cast('now' as timestamp)) 
            >= u.max_time_to_live
        and i.mon$page_marks = 0            
)
and not exists(
    select * 
    from m 
    where lower(trim(a.mon$remote_process)) similar to 
          '%[\\/]*' || lower(trim(m.special_process)) || '(.exe){0,1}'
)
and not exists(
    select * 
    from p 
    where a.mon$remote_address similar to p.special_address || '/[[:DIGIT:]]{4,5}'
)
;
]]>                
            </programlisting>

            <para>Результат этого запроса можно обрабатывать как курсор (например, чтобы
                протоколировать сведения об отключаемых соединениях для последующего
                анализа):</para>
            <programlisting language="sql">
<![CDATA[
for 
    select a.mon$attachment_id 
    from mon$attachments where ... /* см. вышеприведенный запрос */
    into v_old_attachment_id
do
begin
    insert into deleted_log( attach_id ) values( :v_old_attachment_id );
    delete from mon$attachments where mon$attachment_id = :v_old_attachment_id;
end
]]>                
            </programlisting>

            <para>Так же несложно переделать его под одно delete-выражение, и удалять соединения без
                каких-либо дополнительных действий:</para>
            <programlisting language="sql">
<![CDATA[
delete
from mon$attachments a
where 
  exists(
    select 1 
      from mon$transactions t
      join mon$io_stats i on t.mon$stat_id = i.mon$stat_id
      where 
        a.mon$attachment_id = t.mon$attachment_id
        and t.mon$read_only = 0
        and t.mon$isolation_mode <> 2
        and datediff(second from t.mon$timestamp to cast('now' as timestamp)) >= 1
        and i.mon$page_marks = 0          
)
  and not exists(
    select * 
    from
    (
      select 'gfix' as special_process from rdb$database union all
      select 'gstat' from rdb$database union all
      --select 'isql' from rdb$database union all
      select 'fbsvcmgr' from rdb$database
    ) m
    where lower(trim(a.mon$remote_process)) similar to 
            '%[\\/]*' || lower(trim(m.special_process)) || '(.exe){0,1}'
)
and not exists(
  select * 
  from 
  (
    select '127.0.0.1' as special_address from rdb$database union all
    select '192.168.15.1'  from rdb$database union all
    select '192.168.17.1'  from rdb$database union all
    select '192.168.1.5' from rdb$database
  ) p
  where a.mon$remote_address similar to p.special_address || '/[[:DIGIT:]]{4,5}'
)
;
]]> 
                </programlisting>

            <note>
                <para>Удаление подключения работает все контекста транзакции, то есть сразу в момент
                    удаления записи. Отменить его нельзя, ROLLBACK здесь не работает.</para>
            </note>
            <simplesect>
                <title>Замечание о mon$stat_id</title>

                <para>Соединение таблиц mon$transactions и mon$io_stats выполняется по полю
                    mon$stat_id, которое в документации называется <quote>Идентификатор
                        статистики</quote>. Это поле хранит ID <emphasis>вида</emphasis> собираемой
                    информации в рамках текущего снимка и при создании нового mon$-снимка в это поле
                    прописываются новые значения.</para>
                <para>НЕЛЬЗЯ рассчитывать на то, что после старта нового снимка поле mon$stat_id
                    сохранит прежние значения.</para>

                <para>Ниже показан пример для случая, когда выполнен одиночное подключение к FB 3.+
                    и нас интересует информация из mon$io_stats для КОННЕКТОВ (три строки выводятся
                    по тому, что при работе ФБ в архитектуре SuperServer помимо обычного подключению
                    от пользователя присутствуют два системных соединения — от Cache Writer и
                    Garbage Collector):</para>
                <screen>
<![CDATA[
[root@test-nnkk tmp]# /opt/firebird/bin/isql localhost:/var/tmp/tmptest.fdb
Database: localhost:/var/tmp/tmptest.fdb, User: SYSDBA

SQL> commit; 
SQL> select * from mon$io_stats where mon$stat_group = 1 
CON> order by mon$stat_group, mon$stat_id;

MON$STAT_ID           8
MON$STAT_GROUP        1
MON$PAGE_READS       42
MON$PAGE_WRITES       5
MON$PAGE_FETCHES    393
MON$PAGE_MARKS        9

MON$STAT_ID          19
MON$STAT_GROUP        1
MON$PAGE_READS        0
MON$PAGE_WRITES       0
MON$PAGE_FETCHES      2
MON$PAGE_MARKS        1

MON$STAT_ID          20
MON$STAT_GROUP        1
MON$PAGE_READS        0
MON$PAGE_WRITES       0
MON$PAGE_FETCHES      2
MON$PAGE_MARKS        1

SQL> commit;
SQL> select * from mon$io_stats where mon$stat_group = 1 
CON> order by mon$stat_group, mon$stat_id;

MON$STAT_ID           8
MON$STAT_GROUP        1
MON$PAGE_READS        0
MON$PAGE_WRITES       0
MON$PAGE_FETCHES      2
MON$PAGE_MARKS        1

MON$STAT_ID           9
MON$STAT_GROUP        1
MON$PAGE_READS        0
MON$PAGE_WRITES       0
MON$PAGE_FETCHES      2
MON$PAGE_MARKS        1

MON$STAT_ID          10
MON$STAT_GROUP        1
MON$PAGE_READS       42
MON$PAGE_WRITES       7
MON$PAGE_FETCHES    399
MON$PAGE_MARKS       13
]]>               
                </screen>

                <para>Таким образом, счетчикам в mon$io_stats, которые относятся к ПОДКЛЮЧЕНИЯМ,
                    соответствуют свои <quote>личные</quote> mon$stat_id (и все они представлены
                    фильтром <code>where mon$stat_group = 1</code>). Аналогично, счетчики в
                    mon$io_stats, относящиеся к ТРАНЗАКЦИЯМ, также представлены своими mon$stat_id и
                    для них будет <code>mon$stat_group = 2</code>. И наконец, для операторов в
                    mon$io_stats будет третья группа записей, также каждая — со своим индивидуальным
                    значением в mon$stat_id и для этих записей фильтрация должна проводиться по
                    условию <code>where mon$stat_group = 3</code>.</para>
                <para>Это же поле (mon$stat_id) используется для нумерации статистик в таблицах
                    mon$memory_usage и mon$recod_stats. Соединение таблиц mon$attachments,
                    mon$transactions и mon$statements с таблицами mon$io_stats, mon$memory_usage и
                    mon$recod_stats выполнять следует именно по mon$stat_id.</para>
            </simplesect>
        </section>
        <section>
            <title>Построение стека вызовов</title>

            <para>Таблица <database class="table">mon$call_stack</database> позволяет получить стек
                вызовов к заданной <quote>программной точке</quote> внутри ХП, функции или триггера.
                Стек вызовов получается рекурсивным запросом, каждый модуль и <quote>точка
                    вызова</quote> в нём (строка и столбец) будут представлены в таком запросе как
                отдельная запись.</para>
            <para>Записи далее можно упорядочить и применить к ним оператор сцепления строк (||),
                чтобы стек вызовов был показан в виде: <code>proc_01(row, col) => proc_02(row, col)
                    => ...</code>, где row, col — позиции внутри тел модулей, где идут вызовы
                нижележащих ХП или PSQL-функций.</para>
            <para>Ниже показан пример, в котором создаются два пакета (каждый содержит по одной ХП)
                и три обычные (standalone) хранимые процедуры. Процедура пакета pkg_01 вызывает
                процедуру пакета pkg_02, которая вызывает standalone-процедуру sp_03. Эта ХП (sp_03)
                вызывает sp_04 и, наконец, так вызывает sp_05. Если в процедуре sp_05 нужно понять,
                откуда пришёл её вызов, то она может вызвать специальную PSQL-функцию
                fn_get_stack(), которая возвращает строку — стек-вызовов. Эту строку мы пишем в
                контекстную переменную уровня сессии (или транзакции — это без разницы). По
                окончании работы процедур обращаемся к этой контекстной переменной и получаем стек
                вызовов самой глубокой ХП — sp_05.</para>
            <para>Текст примера:</para>
            <programlisting language="sql">
<![CDATA[
create or alter procedure sp_05 as begin end;
create or alter procedure sp_04 as begin end;
create or alter procedure sp_03 as begin end;
create or alter package pkg_01 as begin end;
create or alter package pkg_02 as begin end;
commit;

set term ^;
create or alter function fn_get_stack returns varchar(255)
as
  declare v_call_stack varchar(255);
  declare v_line varchar(255);
begin
  v_call_stack='';

  for
    with recursive
    r as (
        select 1 call_level
            ,c.mon$statement_id as stt_id
            ,c.mon$call_id as call_id
            ,c.mon$object_name as obj_name
            ,c.mon$object_type as obj_type
            ,c.mon$source_line as src_row
            ,c.mon$source_column as src_col
        from mon$call_stack c
        where c.mon$caller_id is null

        UNION ALL

        select r.call_level+1
            ,c.mon$statement_id
            ,c.mon$call_id
            ,c.mon$object_name
            ,c.mon$object_type
            ,c.mon$source_line
            ,c.mon$source_column
        from mon$call_stack c
        join r
            on c.mon$caller_id = r.call_id
    )
    ,b as(
        select h.call_level
                       ,h.obj_name
                       ,h.obj_type
                       ,h.src_row
                       ,h.src_col
                       ,count(*)over() cnt
        from r h
        join mon$statements s
            on s.mon$statement_id = h.stt_id
        where s.mon$attachment_id = current_connection
    )
    select obj_name, obj_type, src_row, src_col, call_level
    from b
    where call_level < cnt -- <<< do NOT include THIS sp name in call_stack
    order by call_level -- ::: NB :::
    as cursor c
  do
  begin
    v_line = trim(c.obj_name)||'('||c.src_row||':'||c.src_col||') => ';
    if ( char_length(v_call_stack) + char_length(v_line) >= 255 ) then
      exit;

    if ( v_call_stack NOT containing v_line ) then 
      v_call_stack = v_call_stack || v_line;
  end
  
  if ( v_call_stack > '' ) then
    v_call_stack = substring( v_call_stack from 1 for char_length(v_call_stack)-5 );
  return v_call_stack;
end
^ -- fn_get_stack
commit 
^

create or alter procedure sp_05 
as 
begin
  rdb$set_context('USER_SESSION', 'DEBUG_INFO', fn_get_stack() );
end
^

create or alter procedure sp_04 
as 
begin
  execute procedure sp_05;
end
^

create or alter procedure sp_03 as 
begin
  execute procedure sp_04;
end
^

create or alter package pkg_02 as 
begin 
  procedure pkg02_sp;
end
^

recreate package body pkg_02 as
begin
  procedure pkg02_sp as
  begin
    execute procedure sp_03;
  end
end
^

create or alter package pkg_01 as 
begin 
  procedure pkg01_sp;
end
^

recreate package body pkg_01 as
begin
  procedure pkg01_sp as
  begin
    execute procedure pkg_02.pkg02_sp;
  end
end
^

set term ;^
commit;


set list on;
execute procedure pkg_01.pkg01_sp;

select rdb$get_context('USER_SESSION', 'DEBUG_INFO' ) as debug_info 
from rdb$database;
]]>                
            </programlisting>


            <para>Если сохранить этот код в отдельном скрипте и запустить его, подключившись к
                пустой базе, то на консоли появится следующее:</para>
            <screen>
PKG01_SP(5:9) => PKG02_SP(5:11) => SP_03(3:11) => SP_04(3:8) => SP_05(3:5)         
            </screen>


            <section>
                <title>Замечания о стеке вызовов</title>

                <para>На момент написания этого текста существует несколько ограничений,
                    препятствующих получению стека вызова.</para>

                <simplesect>
                    <title>Замечание 1</title>

                    <para>Нельзя получить стек вызовов, если процедура вызывается из триггера,
                        который создается неявно СУБД для таблицы, являющейся дочерней в связке
                        PK/FK, и при этом ограничение внешнего ключа объявлено с модификатором ON
                        DELETE CASCADE. Скопируйте следующий код в отдельный скрипт и запустите его
                        на пустой базе:</para>
                    <programlisting language="sql">
<![CDATA[
SET TERM !;

CREATE OR ALTER PROCEDURE dbg_get_stack
AS
BEGIN
END!

CREATE OR ALTER PROCEDURE p_01
AS
BEGIN
END!

CREATE OR ALTER PROCEDURE p_02
AS
BEGIN
END!

CREATE OR ALTER PROCEDURE p_03
AS
BEGIN
END!

CREATE OR ALTER PROCEDURE p_04
AS
BEGIN
END!

CREATE OR ALTER PROCEDURE p_00
AS
BEGIN
END!

SET TERM;!

COMMIT;

------------------------------------------------------------------------
RECREATE TABLE dbg_detl (id INT PRIMARY KEY, pid INT);
RECREATE TABLE dbg_main (id INT PRIMARY KEY);
COMMIT;

ALTER TABLE dbg_detl
ADD CONSTRAINT dbg_detl_fk
    FOREIGN KEY (pid)
    REFERENCES dbg_main (id)
    ON DELETE CASCADE;
COMMIT;
------------------------------------------------------------------------

RECREATE TABLE dbg_stack(
  whoami VARCHAR(31),
  call_level INT,
  statement_id INT,
  call_id INT,
  object_name CHAR(31),
  object_type SMALLINT,
  source_line INT,
  source_column INT,
  trn_id INT DEFAULT CURRENT_TRANSACTION);

COMMIT;

SET TERM !;
CREATE OR ALTER PROCEDURE dbg_get_stack (
      a_whoami VARCHAR(31))
AS
  DECLARE call_level INT;
  DECLARE mon$statement_id TYPE OF COLUMN mon$call_stack.mon$statement_id;
  DECLARE mon$call_id TYPE OF COLUMN mon$call_stack.mon$call_id;
  DECLARE mon$object_name TYPE OF COLUMN mon$call_stack.mon$object_name;
  DECLARE mon$object_type TYPE OF COLUMN mon$call_stack.mon$object_type;
  DECLARE mon$source_line TYPE OF COLUMN mon$call_stack.mon$source_line;
  DECLARE mon$source_column TYPE OF COLUMN mon$call_stack.mon$source_column;
  DECLARE v_stt VARCHAR(4096); -- use dyn SQL for watching in trace!
BEGIN
  v_stt = 'with recursive'
       || ' r as ('
       || '    select 1 call_level,'
       || '         c.mon$statement_id,'
       || '         c.mon$call_id,'
       || '         c.mon$object_name,'
       || '         c.mon$object_type,'
       || '         c.mon$source_line,'
       || '         c.mon$source_column'
       || '    from mon$call_stack c'
       || '    where c.mon$caller_id is null'
       || '    UNION ALL'
       || '    select h.call_level+1,'
       || '           c.mon$statement_id,'
       || '           c.mon$call_id,'
       || '           c.mon$object_name,'
       || '           c.mon$object_type,'
       || '           c.mon$source_line,'
       || '           c.mon$source_column'
       || '    from mon$call_stack c'
       || '      join r h'
       || '        on c.mon$caller_id = h.mon$call_id'
       || ')'
       || ' select'
       || '    r.call_level'
       || '   ,r.mon$statement_id'
       || '   ,r.mon$call_id'
       || '   ,r.mon$object_name'
       || '   ,r.mon$object_type'
       || '   ,r.mon$source_line'
       || '   ,r.mon$source_column'
       || ' from r';
  FOR EXECUTE STATEMENT(v_stt)
      WITH AUTONOMOUS TRANSACTION -- ::: NB :::
      INTO
          :call_level,
          :mon$statement_id,
          :mon$call_id,
          :mon$object_name,
          :mon$object_type,
          :mon$source_line,
          :mon$source_column
  DO
  BEGIN
    INSERT INTO dbg_stack (
      whoami,
      call_level,
      statement_id,
      call_id,
      object_name,
      object_type,
      source_line,
      source_column
      --,trn_id
    )
    VALUES (
      :a_whoami,
      :call_level,
      :mon$statement_id,
      :mon$call_id,
      :mon$object_name,
      :mon$object_type,
      :mon$source_line,
      :mon$source_column
      --,current_transaction
    );
  END
END!
SET TERM;!
COMMIT;

---------------------------------
SET TERM !;
CREATE OR ALTER PROCEDURE p_04
AS
  DECLARE n INT;
BEGIN
  -- dummy row 1
  -- dummy row 2
  -- dummy row 3
  -- dummy row 4
  EXECUTE PROCEDURE dbg_get_stack('p_04');
END!

CREATE OR ALTER PROCEDURE p_03
AS
  DECLARE n INT;
BEGIN
  -- dummy row 1
  -- dummy row 2
  -- dummy row 3
  EXECUTE PROCEDURE p_04;
END!

CREATE OR ALTER   PROCEDURE p_02
AS
  DECLARE n INT;
BEGIN
  -- dummy row 1
  -- dummy row 2
  EXECUTE PROCEDURE p_03;
END!

CREATE OR ALTER   PROCEDURE p_01
  AS
DECLARE n INT;
BEGIN
  -- dummy row 1
  EXECUTE PROCEDURE p_02;
END!

---------------------
CREATE OR ALTER TRIGGER dbg_detl_bud
FOR dbg_detl ACTIVE BEFORE UPDATE OR DELETE
AS
BEGIN
  EXECUTE PROCEDURE p_01;
END
!

SET TERM;!

COMMIT;

INSERT INTO dbg_main (id)
VALUES (1);

INSERT INTO dbg_detl (id, pid)
VALUES (1, 1);

INSERT INTO dbg_detl (id, pid)
VALUES (2, 1);

COMMIT;

SET width whoami 15;
SET width object_name 20;

SET LIST ON;
SELECT
  '-----  Case-1: explicit delete records from DETAIL table -----' AS " "
FROM rdb$database;

SET LIST off;

SELECT
    CURRENT_TRANSACTION
FROM rdb$database;

DELETE FROM dbg_detl;

SELECT
    whoami,
    call_level,
    object_name,
    source_line,
    source_column,
    trn_id
FROM dbg_stack;

ROLLBACK;

SET LIST ON;
SELECT
  '-----  Case-2: delete in MAIN table, cascade in DETAIL -----' AS " "
FROM rdb$database;

SET LIST off;

SELECT
    CURRENT_TRANSACTION
FROM rdb$database;

DELETE FROM dbg_main;

SELECT
    whoami,
    call_level,
    object_name,
    source_line,
    source_column,
    trn_id
FROM dbg_stack;

ROLLBACK;

SELECT
    *
FROM dbg_stack;
]]>                        
                    </programlisting>

                    <para>Этот скрипт выдаст на консоль примерно следующее:</para>
                    <screen linenumbering="numbered"><![CDATA[      -----  Case-1: explicit delete records from DETAIL table -----

  CURRENT_TRANSACTION
=====================
                 1252

WHOAMI    CALL_LEVEL OBJECT_NAME         SOURCE_LINE SOURCE_COLUMN    TRN_ID
======== =========== ================== ============ ============= =========
p_04               1 DBG_DETL_BUD                  4             3      1252
p_04               2 P_01                          5             5      1252
p_04               3 P_02                          6             9      1252
p_04               4 P_03                          7            13      1252
p_04               5 P_04                          8            17      1252
p_04               6 DBG_GET_STACK                47             5      1252
p_04               1 DBG_DETL_BUD                  4             3      1252
p_04               2 P_01                          5             5      1252
p_04               3 P_02                          6             9      1252
p_04               4 P_03                          7            13      1252
p_04               5 P_04                          8            17      1252
p_04               6 DBG_GET_STACK                47             5      1252


      -----  Case-2: delete in MAIN table, cascade in DETAIL -----

  CURRENT_TRANSACTION
=====================
                 1256
]]></screen>

                    <para>Здесь видно, что при удалении записей явным образом (<code>Case-1</code>)
                        стек вызовов будет получен, а когда такое же удаление вызывается неявно
                        каскадным триггером, то стек вызовов процедуры p_01 пуст (после строк
                        25...27 ничего нет).</para>
                </simplesect>

                <simplesect>
                    <title>Замечание 2</title>
                    <para>Если вызывать некоторый модуль динамически (через механизм execute
                        statement, далее — ES), то имена всех программных единиц, расположенных выше
                        этого ES, МОГУТ быть "не видимыми" в mon$call_stack. Это значит, что
                        "потолком" для определения стека вызовов будет не процедура верхнего уровня,
                        а та программная единица, в которой находится ES. Чтобы определить, будут ли
                        видны ХП, находящиеся в стеке вызовов выше ES, следует найти места в коде,
                        где к ним есть явное обращение (без ES). Если такие места есть и исследуемая
                        ХП хотя бы 1 раз вызывалась из этих точек (то есть без ES), и после этого НЕ
                        было переподключения к текущей базе, то далее в этой ХП будет виден полный
                        стек, независимо от того, как она сейчас вызвана.</para>

                    <programlisting language="sql">
<![CDATA[
set term ^;
create or alter procedure p_05 as begin end^
create or alter procedure p_04 as begin end^
create or alter procedure p_03( a_use_dynamic_sql smallint) as begin end^
create or alter procedure p_02 as begin end^
create or alter procedure p_01 as begin end^

create or alter function fn_get_stack returns varchar(255)
as
  declare v_call_stack varchar(255);
  declare v_line varchar(255);
begin
  v_call_stack='';

  for
    with recursive
    r as (
        select 1 call_level
              ,c.mon$statement_id as stt_id
              ,c.mon$call_id as call_id
              ,c.mon$object_name as obj_name
              ,c.mon$object_type as obj_type
              ,c.mon$source_line as src_row
              ,c.mon$source_column as src_col
        from mon$call_stack c
        where c.mon$caller_id is null

        UNION ALL
        
        select r.call_level+1
              ,c.mon$statement_id
              ,c.mon$call_id
              ,c.mon$object_name
              ,c.mon$object_type
              ,c.mon$source_line
              ,c.mon$source_column
        from mon$call_stack c
        join r
            on c.mon$caller_id = r.call_id
    )
    ,b as(
        select h.call_level
              ,h.obj_name
              ,h.obj_type
              ,h.src_row
              ,h.src_col
              ,count(*) over() cnt
        from r h
        join mon$statements s
            on s.mon$statement_id = h.stt_id
        where s.mon$attachment_id = current_connection
    )
    select obj_name, obj_type, src_row, src_col, call_level
    from b
    where call_level < cnt -- <<< do NOT include THIS sp name in call_stack
    order by call_level -- ::: NB :::
    as cursor c
  do
  begin
    v_line = trim(c.obj_name)||'('||c.src_row||':'||c.src_col||') => ';
    if ( char_length(v_call_stack) + char_length(v_line) >= 255 )
      then exit;

    if ( v_call_stack NOT containing v_line ) then
     v_call_stack = v_call_stack || v_line;
  end
  if ( v_call_stack > '' ) then
    v_call_stack = substring(v_call_stack from 1 for char_length(v_call_stack)-5);
  return v_call_stack;
end
^ -- fn_get_stack

set term ;^
commit;

recreate table dbg_stack(
   call_using_dyn_sql smallint
  ,call_stack varchar(255)
);
commit;
---------------------------------
set term ^;

create or alter procedure p_05( a_use_dynamic_sql smallint)
as
begin
  insert into dbg_stack(call_using_dyn_sql, call_stack)
  values( :a_use_dynamic_sql, fn_get_stack() );
end
^

create or alter procedure p_04( a_use_dynamic_sql smallint)
as
begin
  execute procedure p_05( a_use_dynamic_sql );
end
^

create or alter procedure p_02( a_use_dynamic_sql smallint)
as
begin
  execute procedure p_03( a_use_dynamic_sql );
end
^

create or alter procedure p_01( a_use_dynamic_sql smallint)
as
begin
  delete from dbg_stack;
  execute procedure p_02(a_use_dynamic_sql);
end
^

set term ;^
commit;


set list on;

---------------------------- _WITH_ usage of ES ------------------------------
set term ^;
create or alter procedure p_03( a_use_dynamic_sql smallint)
as
begin
  execute statement( 'execute procedure p_04 (?)') (a_use_dynamic_sql);
end
^
set term ;^
commit;

execute procedure p_01(1);
select * from dbg_stack;
commit;


--------------------------- WITHOUT usage of ES -----------------------------
set term ^;
create or alter procedure p_03( a_use_dynamic_sql smallint)
as
begin
  execute procedure p_04( a_use_dynamic_sql );
end
^
set term ;^
commit;

execute procedure p_01(0);
select * from dbg_stack;
]]>                            
                        </programlisting>

                    <para>Выполнение этого скрипта приведет к появлению следующего результата: </para>
                    <screen>
CALL_USING_DYN_SQL 1 -- это выдал код, отмеченный выше тегом "_WITH_ usage of ES"
CALL_STACK         P_04(3:17)=> P_05(3:13)

CALL_USING_DYN_SQL 0 -- это выдал код, отмеченный выше тегом "WITHOUT usage of ES"
CALL_STACK         P_01(4:13)=> P_02(3:17)=> P_03(3:21)=> P_04(3:17)=> P_05(3:13)
                    </screen>

                    <para>Если же поменять местами блоки кода, отмеченные как "_WITH_ usage of ES" и
                        "WITHOUT usage of ES", то вывод будет таким:</para>
                    <screen>
CALL_USING_DYN_SQL 0
CALL_STACK         P_01(4:13)=> P_02(3:17)=> P_03(3:21)=> P_04(3:17)=> P_05(3:13)

CALL_USING_DYN_SQL 1
CALL_STACK         P_01(4:13)=> P_02(3:17)=> P_03(3:21)=> P_04(3:17)=> P_05(3:13)                    </screen>

                    <para>Если же вставить строку переподключения к базе:</para>
                    <programlisting language="sql">
<![CDATA[
------------------------------ WITHOUT usage of ES -------------------------------
set term ^;
create or alter procedure p_03 (a_use_dynamic_sql smallint)  
as
begin
  execute procedure p_04 (a_use_dynamic_sql);
end
^
set term ;^
commit;

execute procedure p_01(0);
select * from dbg_stack;

------------------------------ _WITH_ usage of ES --------------------------------
set term ^;
create or alter procedure p_03( a_use_dynamic_sql smallint)  
as
begin
  execute statement ('execute procedure p_04(?)') (a_use_dynamic_sql);
end
^
set term ;^
commit;

connect 'localhost:employee' user SYSDBA password 'masterkey';

execute procedure p_01(1);
select * from dbg_stack;
commit;
]]>                        
                    </programlisting>
                    <para>то результат для "_WITH_ usage of ES" станет таким же, как и в первом
                        случае, то есть <quote>усеченным</quote>:</para>
                    <screen>
CALL_USING_DYN_SQL  0
CALL_STACK          P_01(4:13)=> P_02(3:17)=> P_03(3:21)=> P_04(3:17)=> P_05(3:13)
    
CALL_USING_DYN_SQL  1
CALL_STACK          P_04(3:17)=> P_05(3:13)                        
                    </screen>

                </simplesect>
            </section>
        </section>
        <section>
            <title>Статистика по таблицам (mon$record_stats)</title>

            <para>В Firebird 3 появились новые поля в таблице мониторинга mon$record_stats,
                позволяющие проводить анализ количества версий записей, встречавшихся при работе
                запроса, степень фрагментированности записей, а также количество конфликтов
                блокировок.</para>

            <para>Таблица mon$record_stats содержит накопительные данные с момента первого
                подключения к БД, поэтому для практических целей большее значение имеют не столько
                числовые поля-счетчики этой таблицы, сколько их разности между двумя
                замерами.</para>

            <para>Например, можно регистрировать в специальной GTT значения счетчиков из следующего
                SQL-выражения:</para>
            <programlisting language="sql">
<![CDATA[
select
    ------------------------ mon$io_stats: -----------------------
    i.mon$page_reads
    ,i.mon$page_writes
    ,i.mon$page_fetches
    ,i.mon$page_marks
    ------------------------ mon$record_stats: -------------------
    ,r.mon$record_inserts
    ,r.mon$record_updates
    ,r.mon$record_deletes
    ,r.mon$record_backouts
    ,r.mon$record_purges
    ,r.mon$record_expunges
    ,r.mon$record_seq_reads
    ,r.mon$record_idx_reads
    ,r.mon$record_rpt_reads
    ,r.mon$backversion_reads
    ,r.mon$fragment_reads
    ,r.mon$record_locks
    ,r.mon$record_waits
    ,r.mon$record_conflicts
    ------------------------ mon$memory_usage: -----------------
    ,u.mon$memory_used
    ,u.mon$memory_allocated
    ,a.mon$stat_id
    ,a.mon$server_pid
from mon$attachments a
left join mon$memory_usage u on a.mon$stat_id=u.mon$stat_id     
left join mon$io_stats i on a.mon$stat_id=i.mon$stat_id     
left join mon$record_stats r on a.mon$stat_id=r.mon$stat_id     
where     
   a.mon$attachment_id = current_connection
;
]]>                
            </programlisting>
            <para>— и затем выполнять интересующий запрос и снова регистрировать показания из
                вышеприведенного выражения. </para>
            <para>Разность между одноименными счетчиками даст возможность проанализировать
                эффективность рабочего запроса.</para>
            <para>Счетчик mon$backversion_reads учитывает чтение цепочек версий записи. Следует
                обращать внимание на значение дроби:</para>
            <programlisting>
mon$backversion_reads / (mon$record_seq_reads + 
                         mon$record_idx_reads + mon$record_rpt_reads) * 100
            </programlisting>

            <para>Если это число более 20%, то имеется проблема с накоплением мусорных версий
                записей, либо мусор просто не успевает собираться. В идеале число чтений версий не
                должно превышать 10-20% над числом чтений записей.</para>
            <para>Также, интересен счетчик mon$record_rpt_reads. Он показывает количество повторных
                чтений (из страничного кеша Firebird или из памяти) ранее прочитанной записи с
                известным dbkey. Этот счетчик будет увеличиваться при update/delete записей в
                before-триггерах, а также при изменении сортированных курсоров</para>
            <programlisting>
{update | delete from}
&lt;<replaceable>table</replaceable>&gt; 
...
order by &lt;<replaceable>expr</replaceable>&gt;
                </programlisting>
            <para>Значение счетчика mon$record_waits показывают количество ожиданий транзакциями,
                запущенными в режиме WAIT или LOCK_TIMEOUT, завершения конкурирующих транзакций,
                ранее изменивших те же самые записи.</para>
            <para>Значение счетчика mon$record_locks — это число успешных блокировок записей
                выражениями вида SELECT ... WITH LOCK.</para>
            <para>Счетчик mon$record_conflicts — число неудачных попыток обновления/удаления записи
                из-за наличия конкурирующих транзакций, ранее изменивших ту же самую запись. В таких
                ситуациях сообщается о конфликте обновления (UPDATE CONFLICT).</para>

        </section>
        <section>
            <title>Поиск подключений, выполненных старыми версиями клиента</title>

            <para>Если в трассировке вы будете видеть заголовочные блоки, в которых нет информации о
                подключенном приложении:</para>
            <screen>
2017-12-18T20:05:36.0660 (1664:00E724E8) START_TRANSACTION
     e30 (ATT_263, SYSDBA:NONE, NONE, TCPv4:127.0.0.1/1447)
          (TRA_1280, READ_COMMITTED | NO_REC_VERSION | WAIT | READ_WRITE)                    
                </screen>
            <para>— проверьте, нет ли к базе подключений, выполненных с использованием клиентских
                библиотек до версии 2.0.7. Они не сообщали свою версию, поэтому в поле
                MON$CLIENT_VERSION для таких подключений остается <literal>NULL</literal>. Выполнить
                такую проверку просто:</para>
            <programlisting language="sql">
set list on;

select mon$remote_address from mon$attachments 
where mon$remote_protocol is not null 
  and mon$client_version is null;                
            </programlisting>

            <note>
                <para>JDBC-драйвер JayBird, используемый для подключения к Firebird java-приложений,
                    не требует наличия стандартной клиентской библиотеки fbclient. Этот драйвер
                    также не показывает имя подключившегося приложения, трассировка для него будет
                    выглядеть аналогично вышеприведенному фрагменту. Вы должны самостоятельно
                    убедиться в том, что по найденным IP-адресам действительно выполнялись
                    подключения с использованием старых версий fbclient-библиотек.</para>
            </note>
        </section>

        <section>
            <title>О причинах расхождений в статистике мониторинга и трассировки</title>

            <para>При включенных опциях <parameter>log_statement_finish</parameter> и
                    <parameter>print_perf</parameter> трассировка будет показывать для завершенного
                запроса (statement) статистику, вычисленную только для этого запроса, и больше ни
                для чего. Если перед и после запроса снять показания счетчиков мониторинга, а затем
                вычислить арифметические разности одноименных счетчиков, то почти всегда будет
                заметна, что эти разности (fetches, marks, reads, writes) превышают аналогичные
                значения в трассировке.</para>
            <para>Причина этого в том, что мониторинг показывает статистику не для отдельного
                запроса (statement), а для всего подключения. Разности показаний счетчиков для
                подключения могут оказаться больше "трейсовых" аналогов как минимум для таблиц
                словаря (RDB$). Для пользовательских таблиц они чаще всего совпадают, но могут быть
                нюансы: хотя счетчики и для mon$table_stats и для трассировки одни и те же, но
                сниматься могут в немного разное время.</para>
            <para>Рассмотрим пример (предполагается, что строка подключения здесь:
                'localhost:employee', user/password: SYSDBA/masterkey):</para>
            <programlisting language="sql">
<![CDATA[                
recreate table monlog(
         mult smallint
        ,page_reads bigint
        ,page_writes bigint
        ,page_fetches bigint
        ,page_marks bigint
        ,record_inserts bigint
        ,record_backouts bigint
        ,record_purges bigint
        ,record_expunges bigint
        ,record_seq_reads bigint
        ,record_idx_reads bigint
        ,record_rpt_reads bigint
        ,backversion_reads bigint
)
;

recreate view vmon as
    select
        ------------------------ mon$io_stats: -----------------------
         i.mon$page_reads
        ,i.mon$page_writes
        ,i.mon$page_fetches
        ,i.mon$page_marks
        ------------------------ mon$record_stats: -------------------
        ,r.mon$record_inserts
        ,r.mon$record_backouts
        ,r.mon$record_purges
        ,r.mon$record_expunges
        ,r.mon$record_seq_reads
        ,r.mon$record_idx_reads
        ,r.mon$record_rpt_reads
        ,r.mon$backversion_reads
    from mon$attachments a
    left join mon$io_stats i on a.mon$stat_id=i.mon$stat_id     
    left join mon$record_stats r on a.mon$stat_id=r.mon$stat_id     
    where     
        a.mon$attachment_id = current_connection
    ;

recreate table test1(s varchar(255) unique using index test1_s_unq);
recreate table test2(s varchar(255) unique using index test2_s_unq);
commit;

insert into test2(s) values( lpad('',255, 'QWERTY' ) );

set term ^;
execute block 
as
    declare n int = 1001;
    declare i int = 0;
begin
    while (i < n) do
    begin
        insert into test1(s) 
        values (iif(:i < :n-1, 
                    lpad('',255, uuid_to_char(gen_uuid())), 
                    lpad('',255, 'QWERTY')));
        i = i + 1;
    end
end
^
set term ;^
commit;

connect 'localhost:e30' user sysdba password 'masterkey';

set list on;

insert into monlog 
select -1, m.* from vmon m;
commit;

insert into test2 select * from test1;

insert into monlog 
select 1, m.* from vmon m;
commit;

select 
     sum( mult * page_reads ) diff_page_reads
    ,sum( mult * page_writes ) diff_page_writes
    ,sum( mult * page_fetches ) diff_page_fetches
    ,sum( mult * page_marks ) diff_page_marks
    ,sum( mult * record_inserts ) diff_record_inserts
    ,sum( mult * record_backouts ) diff_record_backouts
    ,sum( mult * record_purges ) diff_record_purges
    ,sum( mult * record_expunges ) diff_record_expunges
    ,sum( mult * record_seq_reads ) diff_record_seq_reads
    ,sum( mult * record_idx_reads ) diff_record_idx_reads
    ,sum( mult * record_rpt_reads ) diff_record_rpt_reads
    ,sum( mult * backversion_reads ) diff_backversion_reads
from monlog;           
]]>
            </programlisting>

            <para>Запуск этого скрипта приведет к выводу следующих данных (текст исключения по PK/UK
                не показан):</para>
            <screen>
    DIFF_PAGE_READS                 54
    DIFF_PAGE_WRITES                163
    DIFF_PAGE_FETCHES               16585
    DIFF_PAGE_MARKS                 5731
    DIFF_RECORD_INSERTS             1002
    DIFF_RECORD_BACKOUTS            1001
    DIFF_RECORD_PURGES              0
    DIFF_RECORD_EXPUNGES            0
    DIFF_RECORD_SEQ_READS           1001
    DIFF_RECORD_IDX_READS           23
    DIFF_RECORD_RPT_READS           0
    DIFF_BACKVERSION_READS          0                
            </screen>

            <para>Вышеприведенные значения — это стоимость выполнения запроса <code>insert into
                    test2 select * from test1;</code>, при котором в таблицу test2 вставилось 1000
                строк, а на 1001-й записи была попытка добавить дубль и все изменения (все
                добавленные строки) были отменены.</para>

            <para>В трассировке этот же DML-оператор выдаст следующую статистику:</para>
            <screen>
2017-12-18T21:01:33.5760 (1664:00E752E8) FAILED EXECUTE_STATEMENT_FINISH
...
insert into test2 select * from test1
0 records fetched
     152 ms, 43 read(s), 156 write(s), 16491 fetch(es), 5723 mark(s)

Table                       Natural   Index   Update   Insert   Delete   Backout
*********************************************************************************
RDB$INDICES                               1
RDB$RELATION_CONSTRAINTS                  1
TEST1                          1001
TEST2                                     1              1001               1001 
            </screen>

            <para>Здесь видно, что отличие в количестве чтений из страничного кеша Firebird
                (fetches) составляет более 100 фетчей в пользу мониторинга. Также заметны
                относительные отличия в числе чтений из кеша операционной системы (reads): 54 vs 43,
                и записи в него (writes): 163 vs 156.</para>
            <para>Одной из частых причин, когда показаниями мониторинга и трассировки расходятся
                достаточно сильно, является операция Backout — отмена действий запроса (statement)
                (например, из-за того что на поздней его стадии было обнаружено нарушение PK/UK, как
                в данном примере). Операция backout всегда будет регистрироваться в mon$-таблицах,
                но в счетчики с затратами отмененного запроса (в трассировке) эта операция не
                входит.</para>
        </section>
        <section>
            <title>Мониторинг и выполнение запросов</title>

            <section>
                <title>Фаза подготовки запросов</title>

                <para>Фаза подготовки (prepare) для некоторых запросов может оказаться весьма
                    значительной. Существуют запросы, для которых prepare-фаза может длится
                    несколько минут. До момента окончания prepare-фазы ни трассировка, ни
                    mon$-таблицы не будут показывать никакой активности того подключения, которое
                    запустило подготовку такого запроса. Лог трассировки будет пустым, а счетчики
                    табличной статистики застынут (mon$record_stats) на некотором значении и
                    меняться уже не будут. Запрос к mon$attachments покажет данные по этому
                    подключению, но запрос к mon$statements не покажет для него ни одной строки.
                    Запрос появится в mon$statements только после того, как начнет
                    выполняться.</para>

                <para>Об активности подключения в таких случаях будет говорить только сильная
                    загрузка CPU (при условии, что работает только одно подключение, либо если
                    наблюдение идет за Firebird, который работает в архитектуре Classic Server и нам
                    известен mon$server_pid этого соединения).</para>
            </section>

            <section>
                <title>Запросы с состоянием stalled</title>

                <para>Состояние <quote>stalled</quote> (<code>mon$statements.mon$state = 2</code>)
                    означает, что в данный момент происходит перерыв между клиентскими выборками
                    записей из курсора (так называемыми фетчами). То есть запрос создал курсор, его
                    обработка еще не дошла до EOF, и в данный момент выборка курсором не делается
                    (клиент обрабатывает предыдущую порцию данных).</para>

                <para>Состояние <quote>stalled</quote> легко увидеть, если в первом сеансе запустить
                    запрос, который будет передавать на клиента множество записей: </para>
                <formalpara>
                    <title>сеанс 1:</title>
                    <para>
                        <programlisting language="sql"><![CDATA[                            
out nul; 
select f1.rdb$field_name 
from rdb$fields f1, rdb$fields f2, rdb$fields f3, rdb$fields f4;
]]></programlisting>
                    </para>
                </formalpara>
                <formalpara>
                    <title>сеанс 2:</title>
                    <para>
                        <programlisting language="sql"><![CDATA[
set list on;
commit; 
select mon$state, mon$timestamp, mon$sql_text 
from mon$statements 
where mon$attachment_id <> current_connection;
]]></programlisting>
                    </para>
                </formalpara>
                <formalpara>
                    <title>вывод:</title>
                    <para>
                        <screen>
    MON$STATE                       2 // "stalled"
    MON$TIMESTAMP                   2017-12-19 20:30:52.9060
    MON$SQL_TEXT                    0:4
    
select f1.rdb$field_name 
from rdb$fields f1, rdb$fields f2, rdb$fields f3, rdb$fields f4    
                        </screen>
                    </para>
                </formalpara>
                <para>Однако, если поменять запрос на такой, который будет делать всю обработку
                        <quote>внутри себя</quote> и выдавать клиенту только конечный
                    результат:</para>
                <formalpara>
                    <title>сеанс 1:</title>
                    <para>
                        <programlisting language="sql"><![CDATA[                            
out nul; 
select count(*) 
from rdb$fields f1, rdb$fields f2, rdb$fields f3, rdb$fields f4;
]]></programlisting>
                    </para>
                </formalpara>
                <formalpara>
                    <title>вывод:</title>
                    <para>в сеансе_2 будет видно другое состояние запроса: 1, <quote>Active</quote>
                        <screen>
    MON$STATE                       1
    MON$TIMESTAMP                   2017-12-19 20:42:03.4060
    MON$SQL_TEXT                    0:4
    
select f1.rdb$field_name 
from rdb$fields f1, rdb$fields f2, rdb$fields f3, rdb$fields f4    
                        </screen>
                    </para>
                </formalpara>
            </section>
        </section>
        <section>
            <title>Мониторинг расхода памяти</title>

            <para>Таблица mon$memory_usage показывает всегда ТЕКУЩИЙ расход памяти. Счетчики в ней,
                в отличие от других таблиц — НЕ накопительные. В этом легко убедиться, если
                запустить два подключения к БД, и выполнить в одном из них внешнюю сортировку
                большого объема данных. Обращение к mon$memory_usage до и после выполнения внешней
                сортировки выдаст очень незначительную разницу в расходе памяти.</para>

            <para>Например, если сформировать <quote>широкую</quote> таблицу в 1 млн строк:</para>
            <programlisting language="sql">
create table t(
  id int primary key, 
  dts timestamp, 
  s varchar(16384)); 
commit;

insert into t 
select 
  row_number()over(), 
  dateadd(rand()*10000000 second to timestamp '01.01.2000 00:00:00'), 
  rpad('', 16384, uuid_to_char(gen_uuid())) 
from rdb$types, 
     rdb$types,
     (select 1 i from rdb$types rows 20) 
rows 1000000; 
commit;                    
                </programlisting>
            <para>и затем выполнить мониторинг расхода памяти для запроса внешней сортировки:</para>
            <programlisting language="sql">
out /dev/null; 
set stat on;
select id,s from t order by dts;
out; 
set stat on;                    
                </programlisting>
            <para>то будет получен примерно такой результат:</para>
            <programlisting language="sql">
commit; 
select 
  mon$stat_id as stat_id,
  mon$stat_group as stat_group, 
  mon$memory_used as memory_used, 
  mon$memory_allocated as memory_allocated 
from mon$memory_usage 
order by 2, 1;                    
                </programlisting>
            <screen>
     STAT_ID STAT_GROUP           MEMORY_USED      MEMORY_ALLOCATED
============    ======= ===================== =====================
           1          0            2450608416            2453884856
           2          1                611392               1245184
           6          1                  9696                131072
           7          1                178240                262144
           3          2                  1112                 65536
           4          2                  8880                 65536
           5          3                 14056                 65536 
                </screen>
            <programlisting language="sql">
out /dev/null; 
set stat on;
select id,s from t order by dts;                    
                </programlisting>
            <screen>
Current memory = 2450920168
Delta memory = 296288
Max memory = 4591129832
...                    
                </screen>
            <programlisting>
out; set stat off;                    
                </programlisting>
            <programlisting language="sql">
commit; 
select 
  mon$stat_id as stat_id,
  mon$stat_group as stat_group, 
  mon$memory_used as memory_used, 
  mon$memory_allocated as memory_allocated 
from mon$memory_usage 
order by 2, 1;                    
                </programlisting>
            <screen>
     STAT_ID STAT_GROUP           MEMORY_USED      MEMORY_ALLOCATED
============ ========== ===================== =====================
           1          0            2450865288            2454609392
           2          1                771320               1638400
           6          1                  9696                131072
           7          1                178240                262144
           3          2                  1112                 65536
           4          2                  8880                 65536
           5          3                 13784                 65536               
                </screen>
            <para>Здесь видно, что никакого существенного изменения в расходе памяти нет. Причина в
                том, что счетчики mon$memory_used и mon$memory_allocated всегда показывают текущее
                потребление памяти. Чтобы увидеть расход, требовавшийся для выполнения запроса,
                нужно делать опрос mon$memory_usage именно в те моменты, когда этот запрос
                выполняется, то есть до его завершения.</para>
        </section>
        <section>
            <title>Мониторинг и nbackup</title>

            <section>
                <title>Снятие файловой копии базы</title>

                <para>При выполнении команды <code>nbackup -b 0</code> следует учитывать, что
                        <application>nbackup</application> выполняет очень кратковременное
                    подключение к базе для установки на неё блокировки, после чего отключается от
                    базы и начинает выполнять её копирование средствами операционной системы. Всё
                    это время <application>nbackup</application> не будет виден в списке подключений
                    через mon$attachments. Вот пример того, что будет показано в трассировки для
                    команды старта <application>nbackup</application> (разность отметок времени
                    установки подключения и отключения составляет всего 30 мс):</para>
                <screen><![CDATA[                    
2017-12-19T16:03:58.6230 (9319:0x7ff627708f28) ATTACH_DATABASE
        /var/db/fb30/gfixtest30.fdb (ATT_44, SYSDBA:NONE, NONE, <internal>)
...
2017-12-19T16:03:58.6260 (9319:0x7ff627708f28) EXECUTE_STATEMENT_FINISH
...
ALTER DATABASE BEGIN BACKUP
...

2017-12-19T16:03:58.6260 (9319:0x7ff627708f28) DETACH_DATABASE
        /var/db/fb30/gfixtest30.fdb (ATT_44, SYSDBA:NONE, NONE, <internal>)                    
]]></screen>
                <para>Следующее подключение от <application>nbackup</application> будет также
                    кратковременным и служит для снятия флага блокировки с БД. Действия
                        <application>nbackup</application> (его активность) в этом случае проще
                    увидеть в журнале трассировки, если задать фильтрацию вызовов сервисов по
                    строке: <quote>Incremental Backup Database</quote>.</para>
            </section>
            <section>
                <title>Заливка .delta-файла обратно в базу</title>

                <para>Если файл базы был сначала заблокирован для снятия с него файловой копии без
                    отключения пользователей (<code>nbackup -L</code>), а затем в этот файл начинает
                    записываться <filename>.delta</filename> (<code>nbackup -N</code>), то
                    мониторинг будет возможен только для того сеанса, который в это время не делает
                    переподключение к базе, то есть уже имеет подключение. Запрос к <database
                        class="table">mon$attachments</database> для процесса
                        <application>nbackup</application> вернёт следующее:</para>
                <screen>
MON$ATTACHMENT_ID               19
MON$SERVER_PID                  17846
MON$STATE                       0
MON$ATTACHMENT_NAME             /var/tmp/tmp.fdb
MON$USER                        SYSDBA
MON$ROLE                        NONE
MON$REMOTE_PROTOCOL             TCPv6
MON$REMOTE_ADDRESS              ::1/46656
MON$REMOTE_PID                  17880
MON$CHARACTER_SET_ID            0
MON$TIMESTAMP                   2017-12-19 17:01:58.3060
MON$GARBAGE_COLLECTION          1
MON$REMOTE_PROCESS              /opt/firebird/bin/nbackup
MON$STAT_ID                     11
MON$CLIENT_VERSION              LI-V3.0.3.32838 Firebird 3.0 HQbird
MON$REMOTE_VERSION              P15
MON$REMOTE_HOST                 test.company.ru
MON$REMOTE_OS_USER              test
MON$AUTH_METHOD                 Legacy_Auth
MON$SYSTEM_FLAG                 0                    
                </screen>
                <para>Однако, все новые подключения к базе будет невозможно установить до тех пор,
                    пока длится <quote>заливка</quote> .delta-файла</para>
            </section>
        </section>
    </section>
</chapter>
